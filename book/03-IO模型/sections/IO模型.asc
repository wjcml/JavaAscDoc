=== I/O模型

==== 同步/异歩，阻塞/非阻塞

`*在了解 I/O 之前，需要先知道几个重要的概念，什么是同步/异歩，阻塞/非阻塞。*`

[NOTE]
这四个概念很 `重要`，必须弄清楚这几个概念，特别是同步和阻塞，异步和非阻塞的区别

.同步/异步
`*同步 ：两个同步任务相互依赖，并且一个任务必须以依赖于另一任务的某种方式执行。 比如在A->B事件模型中，你需要先完成 A 才能执行B。 再换句话说，同步调用中被调用者未处理完请求之前，调用不返回，调用者会一直等待结果的返回。*`

`*异步： 两个异步的任务完全独立的，一方的执行不需要等待另外一方的执行。再换句话说，异步调用种一调用就返回结果不需要等待结果返回，当结果返回的时候通过回调函数或者其他方式拿着结果再做相关事情。*`

.阻塞/非阻塞
`*阻塞： 阻塞就是发起一个请求，调用者一直等待请求结果返回，也就是当前线程会被挂起，无法从事其他任务，只有当条件就绪才能继续。*`

`*非阻塞： 非阻塞就是发起一个请求，调用者不用一直等着结果返回，可以先去干其他事情。*`

[NOTE]
如何区分 “同步/异步 ”和 “阻塞/非阻塞” 呢？ + 
`*同步/异步是从行为角度描述事物的，而阻塞和非阻塞描述的当前事物的状态（等待调用结果时的状态）。*`


'''


==== 五种I/O模型
参考文章： https://mp.weixin.qq.com/s?__biz=Mzg3MjA4MTExMw==&mid=2247484746&idx=1&sn=c0a7f9129d780786cabfcac0a8aa6bb7&source=41#wechat_redirect[漫画编程--如何给女朋友解释什么是Linux的五种IO模型？]

[NOTE]
====
在一次I/O操作，数据会先拷贝到 `内核空间` 中，然后再从内核空间拷贝到 `用户空间` 中

- 1. 等待数据准备（将数据拷贝到 `内核空间` ）
- 2. 数据从内核空间拷贝到 `用户空间`
====


`在Linux(UNIX)操作系统中，共有五种IO模型，分别是：阻塞IO模型、非阻塞IO模型、IO复用模型、信号驱动IO模型以及异步IO模型。`

.阻塞IO模型
`从进程发起IO操作，一直等待上述两个阶段完成，此时两阶段一起阻塞。`

image::阻塞IO模型.png[]

.非阻塞IO模型
`进程一直询问IO准备好了没有（轮询），准备好了再发起读取操作，这时才把数据从内核空间拷贝到用户空间。第一阶段不阻塞但要轮询，第二阶段阻塞。`

image::非阻塞IO模型.png[]

.IO复用模型
`多个连接使用同一个select去询问IO准备好了没有，如果有准备好了的，就返回有数据准备好了，然后对应的连接再发起读取操作，把数据从内核空间拷贝到用户空间。两阶段分开阻塞。`

image::IO复用模型.png[]

.信号驱动IO模型
`进程发起读取操作会立即返回，当数据准备好了会以通知的形式告诉进程，进程再发起读取操作，把数据从内核空间拷贝到用户空间。第一阶段不阻塞，第二阶段阻塞。`

image::信号驱动IO模型.png[]

.异步IO模型
`进程发起读取操作会立即返回，等到数据准备好且已经拷贝到用户空间了再通知进程拿数据。两个阶段都不阻塞。`

image::异步IO模型.png[]

[NOTE]
需要注意的是，在这五种IO模型中，`阻塞IO模型、非阻塞IO模型、IO复用模型、信号驱动IO模型`这四种模型属于 `同步IO模型`； `异步IO模型` 才是真正的 `异步IO模型`。这是因为在前四种I模型中，无论在第一步（将数据准备到内核空间中）是阻塞还是非阻塞的，在第二步（将数据从内核空间中拷贝到用户空间中）的时候是阻塞的，所以从整个IO过程来看，是同步的；在异步IO模型中，两个步骤都是非阻塞的，所以是异步的。 + 
 + 
这里容易错误的以为 `信号驱动IO模型` 是异步模型，需要注意一下。

.五种IO模型对比
`通过对五种IO模型的认识，下面这张图对比五种IO模型的区别。`

image::IO模型对比.jpeg[]


==== BIO/NIO/AIO

[NOTE]
在java的IO中，我们可能会经常遇到 `channel` 和 `pipeline` 这两个词，从英语的角度翻译过来都是 `通道，管道` 的意思。我们容易弄不清楚他们的区别。 + 
 + 
NIO的 `channel` 是NIO的核心之一，指的是连接资源的通道，channel用于IO传输，这里的 `pipeline` 只是附带的一个小功能，用线程间数据交互。 + 
 +
channel -> IO通道（远程或本地） + 
pipeline -> jvm进程内的线程间管道


`Java 中的 BIO、NIO和AIO理解为是 Java 语言在操作系统层面对这三种 IO 模型的封装。程序员在使用这些 封装API 的时候，不需要关心操作系统层面的知识，也不需要根据不同操作系统编写不同的代码，只需要使用Java的API就可以了。`

===== BIO

.传统BIO
`采用 BIO 通信模型 的服务端，通常由一个独立的 Acceptor 线程负责监听客户端的连接。我们一般通过在while(true) 循环中服务端会调用 accept() 方法等待接收客户端的连接的方式监听请求，请求一旦接收到一个连接请求，就可以建立通信套接字在这个通信套接字上进行读写操作，此时不能再接收其他客户端连接请求，只能等待同当前连接的客户端的操作执行完成， 不过可以通过多线程来支持多个客户端的连接，如上图所示。`

image::BIO通信模型.png[]


.伪异步IO
`为了解决同步阻塞I/O面临的一个链路需要一个线程处理的问题，后来有人对它的线程模型进行了优化一一一后端通过一个线程池来处理多个客户端的请求接入，形成客户端个数M：线程池最大线程数N的比例关系，其中M可以远远大于N.通过线程池可以灵活地调配线程资源，设置线程的最大值，防止由于海量并发接入导致线程耗尽。`

`采用线程池和任务队列可以实现一种叫做伪异步的 I/O 通信框架，它的模型图如下图所示。当有新的客户端接入时，将客户端的 Socket 封装成一个Task（该任务实现java.lang.Runnable接口）投递到后端的线程池中进行处理，JDK 的线程池维护一个消息队列和 N 个活跃线程，对消息队列中的任务进行处理。由于线程池可以设置消息队列的大小和最大线程数，因此，它的资源占用是可控的，无论多少个客户端并发访问，都不会导致资源的耗尽和宕机。`

`伪异步I/O通信框架采用了线程池实现，因此避免了为每个请求都创建一个独立线程造成的线程资源耗尽问题。不过因为它的底层仍然是同步阻塞的BIO模型，因此无法从根本上解决问题。`

image::伪异步IO模型.png[]


===== NIO
`NIO是一种同步非阻塞的I/O模型。`

.NIO的核心组件
- Channel(通道)
- Buffer(缓冲区)
- Selector(选择器)

image::Slector.png[]

[NOTE]
====
通常来说NIO中的所有IO都是从 Channel（通道） 开始的。

- 从通道进行数据读取 ：创建一个缓冲区，然后请求通道读取数据。 + 
- 从通道进行数据写入 ：创建一个缓冲区，填充数据，并要求通道写入数据。
====

image::NIO读写数据的方式.png[]


===== AIO
`异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。`


=== 索引

*索引是一种用于快速查询和检索数据的数据结构*。常见的索引结构有: *B 树， B+树和 Hash*。

==== 索引分类

按数据结构分类可分为：*B+tree索引、Hash索引*。 + 
按物理存储分类可分为：*聚簇索引、非聚簇索引*。 + 
按字段特性分类可分为：*主键索引、二级索引（辅助索引）*。 + 
按字段个数分类可分为：*单列索引、联合索引（复合索引、组合索引）*。


===== 按数据结构分类


====== Hash索引

哈希表是键值对的集合，通过键(key)即可快速取出对应的值(value)，因此哈希表可以快速检索数据（接近 O（1））。

既然哈希表这么快，*为什么MySQL 没有使用其作为索引的数据结构呢？*

. Hash 冲突问题 ：我们上面也提到过Hash 冲突了，不过对于数据库来说这还不算最大的缺点。

. 因为经过相应的 Hash算法处理之后的 Hash 值的大小关系，并不能保证和Hash运算前完全一样。所以 Hash 索引不支持顺序和范围查询(Hash 索引不支持顺序和范围查询是它最大的缺点： 假如我们要对表中的数据进行排序或者进行范围查询，那 Hash 索引可就不行了。

> > InnoDB实际上也支持Hash索引，但是InnoDB中Hash索引的创建由存储引擎引擎自动优化创建，不能人为干预是否为表创建Hash索引。所以我们平常不考虑Hash索引。

====== B-tree 和 B+tree

- *B 树的所有节点既存放键(key) 也存放 数据(data)，而 B+树只有叶子节点存放 key 和 data，其他内节点只存放 key*。
- B 树的叶子节点都是独立的；B+树的叶子节点有一条引用链指向与它相邻的叶子节点。
- B 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而 B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。


在 MySQL 中，MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是，两者的实现方式不太一样。


===== 按物理存储分类

====== 聚簇索引

*聚簇索引的每个叶子节点存储了一行完整的表数据*，叶子节点间按id列递增连接，可以方便地进行顺序检索。

====== 非聚簇索引

*非聚集索引即索引结构和数据分开存放的索引*。

*二级索引属于非聚集索引*。所以说非聚簇索引可能 *回表查询*。只是说有可能，因为还有一种叫做 *覆盖索引* 的存在。

[NOTE]
====
*覆盖索引*

如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为“覆盖索引”。我们知道在 InnoDB 存储引擎中，如果不是主键索引，叶子节点存储的是主键+列值。最终还是要“回表”，也就是要通过主键再查找一次。这样就会比较慢覆盖索引就是把要查询出的列和索引是对应的，不做回表操作！

覆盖索引即需要查询的字段正好是索引的字段，那么直接根据该索引，就可以查到数据了， 而无需回表查询。
====


===== 按字段特性分类

====== 主键索引

数据表的主键列使用的就是主键索引。

一张数据表有只能有一个主键，并且主键不能为 null，不能重复。

====== 二级索引（辅助索引）

二级索引又称为辅助索引，是因为 *二级索引的叶子节点存储的数据是主键*。也就是说，通过二级索引，可以定位 *主键* 的位置。

*唯一索引，普通索引，前缀索引* 等索引属于二级索引。

- *唯一索引(Unique Key)* ：唯一索引也是一种约束。唯一索引的属性列不能出现重复的数据，但是允许数据为 NULL，一张表允许创建多个唯一索引。 建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率。
- *普通索引(Index)* ：普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和 NULL。
- *前缀索引(Prefix)* ：前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小， 因为只取前几个字符。


===== 按字段个数分类

====== 单列索引

建立在单个列上的索引被称为单列索引。

====== 联合索引（复合索引、组合索引）

建立在多个列上的索引被称为联合索引，又叫复合索引、组合索引。




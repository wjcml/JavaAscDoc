=== 类加载


==== 类加载过程

系统加载 Class 类型的文件主要三步：*加载 -> 连接 -> 初始化*。连接过程又可分为三步：*验证 -> 准备 -> 解析*。

所以说类加载可以分为五个步骤： *加载 -> 验证 -> 准备 -> 解析 -> 初始化*

===== 加载

通过全类名获取定义此类的二进制字节流（比较常见的就是从 zip，jar，war 中读取），并将二进制字节流加载到方法区。

===== 验证

- 验证字节流是否符合Class文件格式规范
- 检查这个类有没有父类，有没有继承不允许继承的类（final修饰的类）
- 检查程序语义是否正确
- 确保解析动作能正确执行

===== 准备

准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。

===== 解析

解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，也就是得到类或者字段、方法在内存中的指针或者偏移量。

===== 初始化

就是执行初始化方法

==== 类加载器

JVM 中内置了三个重要的 ClassLoader，除了 BootstrapClassLoader 其他类加载器均由 Java 实现且全部继承自java.lang.ClassLoader：

- *BootstrapClassLoader(启动类加载器)*：最顶层的加载类，由 C++实现，负责加载 %JAVA_HOME%/lib目录下的 jar 包和类或者被 -Xbootclasspath参数指定的路径中的所有类。
- *ExtensionClassLoader(扩展类加载器)*：主要负责加载 %JRE_HOME%/lib/ext 目录下的 jar 包和类，或被 java.ext.dirs 系统变量所指定的路径下的 jar 包。
- *AppClassLoader(应用程序类加载器)*：面向我们用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类。

===== 双亲委派模型

每一个类都有一个对应它的类加载器。系统中的 ClassLoader 在协同工作的时候会默认使用 *双亲委派模型* 。即在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。加载的时候，首先会把该请求委派给父类加载器的 loadClass() 处理，因此所有的请求最终都应该传送到顶层的启动类加载器 BootstrapClassLoader 中。当父类加载器无法处理时，才由自己来处理。当父类加载器为 null 时，会使用启动类加载器 BootstrapClassLoader 作为父类加载器。

其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式，即每个儿子都很懒，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子自己想办法去完成，这不就是传说中的实力坑爹啊。

image::双亲委派模型.png[]


双亲委派模型保证了 Java 程序的稳定运行，可以避免类的重复加载。






=== RabbitMQ

RabbitMQ 是基于 erlang 开发的，并发能力强，性能极好，延时低。

==== RabbitMQ的组件

*生产者（Producer），消费者（Consumer），经纪人（Broker），交换器（Exchange），消息队列（Queue）*

==== RabbitMQ消息消费流程

下图展示了生产者将消息存入 RabbitMQ Broker,以及消费者从Broker中消费数据的整个流程。

image::RabbitMQ消息使用流程.jpg[]


==== RabbitMQ消息模型

===== 基本消息模型

就是正常的消息消费，生产者生产消息放入队列中，然后消费者消费这条消息

image::RabbitMQ之基本消息模型.png[]

===== work消息模型

工作队列，又称为任务队列。

让多个消费者绑定到一个队列，共同消费队列中的消息，但是一个消息只能被一个消费者获取。队列中的消息一旦消费，就会消失，因此任务是不会被重复执行的。

image::RabbitMQ之work消息模型.png[]


===== 订阅模型（三种）

====== 订阅模型-Fanout（广播）

广播，交换机把消息发送给绑定过的所有队列，实现一条消息被多个消费者消费。

image::RabbitMQ之订阅模型-Fanout.png[]

====== 订阅模型-Direct（定向）

定向，把消息发送给符合指定 routingKey 的队列

image::RabbitMQ之订阅模型-Direct.png[]


====== 订阅模型-Topic（通配符）

通配符，根据通配符把消息发送给符合的队列

image::RabbitMQ之订阅模型-Topic.png[]


==== RabbitMQ如何保证消息不丢失

RabbitMQ 消息丢失分三种情况，生产者丢失消息，rabbitmq自己丢失消息，消费者丢失消息。

下面根据这三种情况分别提出解决方案：

===== 生产者丢失消息

第一种方式： 使用rabbitmq提供的事务功能，开启事务后，如果消息没有成功被rabbitmq接收，生产者就会报错，这时就可以回滚事务，然后尝试重新发送。成功就提交事务。

第二种方式： 可以开启confirm模式，每次写消息都会分配一个唯一的id，如果写入消息成功，会返回一个ack，告诉你消息发送成功；如果写入消息没有成功，就可以回调一个nack接口，告诉你消息发送失败，然后你就可以重试。

需要注意的是： 事务机制是 *同步阻塞* 的；confirm机制是 *异步* 的，因为消息发送失败，rabbitmq会回调告知是否成功。


===== rabbitmq自己丢失消息

可以设置消息持久化到磁盘。


===== 消费者丢失消息

可以关闭掉 rabbitmq 自动的 ack ，使用手动的 ack，每次在确保处理完这个消息之后，在代码里手动调用ack。这样就可以避免消息还没有处理完就ack。






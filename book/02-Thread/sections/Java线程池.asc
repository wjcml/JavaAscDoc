=== Java线程池
*线程池原理*： + 
线程池做的工作主要是控制运行的线程的数量，处理过程中将任务放入队列,然后在线程创建后，启动这些任务,如果线程数量超过了最大数量超出数量的线程排队等候，等其它线程执行完毕，再从队列中取出任务来执行。他的主要特点为: `线程复用`，`控制最大并发数`，`管理线程`。


==== ThreadPoolExecutor (推荐)

ThreadPoolExecutor 创建线程池的几个核心参数： `核心线程数`， `最大线程数`， `超过核心线程数量的线程最大空闲时间`， `时间单位`， `阻塞队列`， `拒绝策略`。

.核心参数的关联关系
. 如果运行的线程数小于 `核心线程数`，提交新任务时就会新建一个线程来运行，即使其他核心线程能够执行新任务也会创建线程；
. 如果运行线程数大于或等于 `核心线程数`，新提交的任务就会加入到 `阻塞队列` 等待；如果队列已满，并且已创建的线程数小于 `最大线程数`，也将会新建一个线程来运行；
. 如果线程数大于 `最大线程数`，新提交的任务将会根据拒绝策略来处理。

[NOTE]
====
需要注意的是： 如果采用 `无界队列` 时， `最大线程数` 和 `超过核心线程数量的线程最大空闲时间` 这两个参数就不起作用了

一般我们称核心线程池中的线程为核心线程，这部分线程不会被回收；超过任务队列后，创建的线程为空闲线程，这部分线程会被回收（回收时间即 keepAliveTime）
====

.阻塞队列入队策略
*直接传递*： 使用 `SynchronousQueue` 作为阻塞队列，线程池的数量无限大，新任务会直接分配或者创建一个线程进行执行。

*无界队列*： 使用无界队列（例如： `LinkedBlockingQueue`）作为阻塞队列，当所有的核心线程都在处理任务时，新提交的任务都会进入队列等待。线程池大小固定，队列长度无限制。

*有界队列*： 使用有界队列（例如： `ArrayBlockingQueue`）作为阻塞队列，可以防止资源耗尽，但是难以调整和控制。队列大小和线程池大小可以相互作用。

.拒绝策略
当线程池已经关闭或达到饱和（最大线程和队列都已满）状态时，新提交的任务将会被拒绝。`ThreadPoolExecutor` 定义了四种拒绝策略：

. *AbortPolicy*：默认策略，在需要拒绝任务时抛出RejectedExecutionException；
. *CallerRunsPolicy*：直接在 execute 方法的调用线程中运行被拒绝的任务，如果线程池已经关闭，任务将被丢弃；
. *DiscardPolicy*：直接丢弃任务；
. *DiscardOldestPolicy*：丢弃队列中等待时间最长的任务，并执行当前提交的任务，如果线程池已经关闭，任务将被丢弃。


.创建线程池
[source, java]
----
// 核心线程数
int corePoolSize = 3;
// 最大线程数
int maximumPoolSize = 6;
// 超过 corePoolSize 线程数量的线程最大空闲时间
long keepAliveTime = 2;
// 以秒为时间单位
TimeUnit unit = TimeUnit.SECONDS;
// 创建工作队列，用于存放提交的等待执行任务
BlockingQueue<Runnable> workQueue = new ArrayBlockingQueue<Runnable>(100);
// 创建线程池
ThreadPoolExecutorthreadPoolExecutor = new ThreadPoolExecutor(corePoolSize,
                    maximumPoolSize,
                    keepAliveTime,
                    unit,
                    workQueue,
                    new ThreadPoolExecutor.AbortPolicy());
----



==== Executors
Executors 创建线程池其实也是通过 `ThreadPoolExecutor` 进行创建的，只不过参数固定，`ThreadPoolExecutor` 参数不固定，在开发中更加符合业务需求，所以更推荐使用 `ThreadPoolExecutor` 创建线程池，
.newCachedThreadPool
[source, text]
----
创建一个可根据需要创建新线程的线程池,但是在以前构造的线程可用时将重用它们。对于执行很多短期异步任务的程序而言,这些线程池通常可提高程序性能。调用 execute 将重用以前构造的线程(如果线程可用)。如果现有线程没有可用的,则创建一个新线程并添加到池中。终止并从缓存中移除那些已有 60 秒钟未被使用的线程。
----

.newFixedThreadPool
[source, text]
----
创建一个可重用固定线程数的线程池,以共享的无界队列方式来运行这些线程。
----

.newScheduledThreadPool
[source, text]
----
创建一个线程池,它可安排在给定延迟后运行命令或者定期地执行。
----

.newSingleThreadExecutor
[source, text]
----
Executors.newSingleThreadExecutor()返回一个线程池(这个线程池只有一个线程),这个线程
池可以在线程死后(或发生异常时)重新启动一个线程来替代原来的线程继续执行下去!
----

[NOTE]
====
Executors 创建线程的弊端：

`newFixedThreadPool` 和 `newSingleThreadExecutor`: 主要问题是堆积的请求处理队列可能会耗费非常大的内存，甚至OOM(内存用完了)。

`newCachedThreadPool` 和 `newScheduledThreadPool`: 主要问题是线程数最大数是Integer.MAX_VALUE，可能会创建数量非常多的线程，甚至OOM。
====




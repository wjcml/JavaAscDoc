=== 线程的生命周期

.线程的6种状态
****
- *初始(NEW)*：新创建了一个线程对象，但还没有调用start()方法。
- *运行(RUNNABLE)*：Java线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”。 + 
线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取CPU的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得CPU时间片后变为运行中状态（running）。
- *等待(WAITING)*：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。
- *阻塞(BLOCKED)*：表示线程阻塞于锁。
- *超时等待(TIMED_WAITING)*：该状态不同于WAITING，它可以在指定的时间后自行返回。
- *终止(TERMINATED)*：表示该线程已经执行完毕。
****

image::线程的生命周期(线程的6种状态).jpeg[]


==== yield()

&emsp;&emsp;线程调用了yield()方法，意思是放弃当前获得的CPU时间片，回到就绪状态，这时与其他进程处于同等竞争状态

==== join()

&emsp;&emsp;使得放弃当前线程的执行，并返回对应的线程。程序在main线程中调用t1线程的join方法，则main线程放弃cpu控制权，并返回t1线程继续执行直到线程t1执行完毕所以结果是t1线程执行完后，才到主线程执行，相当于在main线程中同步t1线程，t1执行完了，main线程才有执行的机会。

==== wait() 和 notify()

&emsp;&emsp;当线程调用wait()方法后会进入等待队列（进入这个状态会释放所占有的所有资源，与阻塞状态不同），进入这个状态后，是不能自动唤醒的，必须依靠其他线程调用notify()或notifyAll()方法才能被唤醒（由于notify()只是唤醒一个线程，但我们由不能确定具体唤醒的是哪一个线程，也许我们需要唤醒的线程不能够被唤醒，因此在实际使用时，一般都用notifyAll()方法，唤醒有所线程），线程被唤醒后会进入锁池，等待获取锁标记。

==== wait() 和 sleep() 的区别

- wait() 来自 Object 类，sleep() 来自 Thread 类
- sleep() 没有释放锁；wait() 释放了锁，让敏感词线程可以使用同步块或方法。
- wait()、notify() 和 notifyAll() 只能在同步方法或控制块里使用，只有在synchronized方法或块中当前线程才占有锁，才有锁可以释放；sleep() 可以在任何地方使用。
- sleep() 必须捕获异常；wait()、notify() 和 notifyAll() 不需要
- wait() 不加时间限制，要等待 notify() 或 notifyAll() 唤醒等待池中所有的线程（执行完 notify() 或 notifyAll() 或 wait() 后，并不立即获得或释放锁，而是执行完同步块后再释放或获得），才会进入就绪队列等待OS分配系统资源；sleep() 可以设置时间唤醒，如果时间不到，只能用interrupt()强行打断。

==== interrupted() 和 isInterrupted() 的区别

- 二个方法都是判断线程是否停止的方法
- 前者是静态方法，后者是非静态方法。interrupted() 是作用于当前正在运行的线程，isInterrupted() 是作用于调用该方法的线程对象所对应的线程。
- 前者会将中断状态清除而后者不会。



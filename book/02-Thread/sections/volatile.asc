=== volatile

参考文档： https://www.cnblogs.com/javazhiyin/p/13521567.html["面试官最爱的 volatile 关键字，这些问题你都搞懂了没？",window="_blank"]

==== 什么是JMM(Java内存模型)

https://zhuanlan.zhihu.com/p/258393139["面试官问我什么是JMM", window="_blank"]

&emsp;&emsp;JMM指的是 在Java中定义了程序中各种变量的访问规范，屏蔽掉各种硬件和操作系统的内存访问差异，以实现让java程序在各种平台下都能达到一致的并发效果。

==== volatile 的作用


被 volatile 修饰的变量具有的特性：

- *保证此变量对所有线程的可见性*
- *禁止指令重排序优化*


===== 指令重排序

&emsp;&emsp; *在不改变程序执行结果的前提下，尽可能提高程序的运行效率* ，意思是在不改变程序运行结果的情况下，调整代码执行顺序，优化程序。（JVM虚拟机的一种优化措施）。

&emsp;&emsp;重排序不会影响单线程环境的执行结果，但是会破坏多线程的执行语义。


[source, java]
----
volatile boolean isOK = false;

//假设以下代码在线程A执行
A.init();
isOK=true;

//假设以下代码在线程B执行
while(!isOK){
  sleep();
}
B.init();
----

&emsp;&emsp;线程在初始化的时候，B线程处于睡眠状态，等待A线程完成初始化的时候才能够进行自己的初始化。这里的先后关系依赖于isOK这个变量。

&emsp;&emsp;如果没有volatile修饰isOK这个变量，那么isOK的赋值就可能出现在A.init()之前（指令重排序,Java虚拟机的一种优化措施），此时A没有初始化，而B的初始化就破坏了它们之前形成的那种依赖关系，可能就会出错。

&emsp;&emsp;volatile关键字通过 “*内存屏障*” 的方式来防止指令被重排序，即：*在每个 volatile 读写操作前后加一种CPU指令*。


[NOTE]
内存屏障: 内存屏障（Memory Barrier，或有时叫做内存栅栏，Memory Fence）是一种CPU指令，用于控制特定条件下的重排序和内存可见性问题。



==== volatile的可见性问题

&emsp;&emsp;内存可见性是指当一个线程修改了某个变量的值，其它线程总是能知道这个变量变化。也就是说，如果线程 A 修改了共享变量 V 的值，那么线程 B 在使用 V 的值时，能立即读到 V 的最新值。

&emsp;&emsp;使用 volatile 修饰共享变量后，每个线程要操作变量时会从主内存中将变量拷贝到本地内存作为副本。当线程操作变量副本并写回主内存后，会通过 *CPU 总线嗅探机制* 告知其他线程该变量副本已经失效，需要重新从主内存中读取。(CPU 总线嗅探机制 是实现缓存一致性的常见机制，想要了解更多可以看看这篇文章 https://zhuanlan.zhihu.com/p/138819184["volatile 关键字，你真的理解吗？", window="_blank"])

所以：

- *每次直接从主内存读取值*。
- *每次写入强制修改主内存的值*。

需要注意的是：volatile 是不能保证原子性的。

[NOTE]
====
&emsp;&emsp;在 Java 内存模型（JMM）中规定：线程之间的共享变量存储在主内存中，每个线程都有一个私有的本地内存，本地内存中存储了该线程以读/写共享变量的副本。这里所说的共享变量指的是实例变量和类变量，不包含局部变量，因为局部变量是线程私有的，因此不存在竞争问题。

- 每一个线程还存在自己的工作内存，线程的工作内存，保留了被线程使用的变量的工作副本。
- 线程对变量的所有的操作（读，取）都必须在工作内存中完成，而不能直接读写主内存中的变量。
- 不同线程之间也不能直接访问对方工作内存中的变量，线程间变量的值的传递需要通过主内存中转来完成。

image::JMM示意图.webp[]
====



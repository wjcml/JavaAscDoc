=== 线程的创建方式

==== Thread
[source,java]
----
public class NewThread extends Thread {
    public void run() {
        System.out.println("通过继承Thread类实现");
    }
}

new Thread（new NewThread()).start();
----

[TIP]
Thread 本质上是实现了 Runable 接口。


==== Runable
[source,java]
----
public class NewThread implements Runnable {
    public void run() {
        System.out.println("通过实现Runable接口实现");
    }
}

new Thread（new NewThread()).start();
----


==== Callable
[source,java]
----
// ExecutorService、Callable<Class>、Future (子线程会有返回值)

public class Test {
    public static void main(String[] args) {
        // 线程池
        ExecutorService executor = Executors.newCachedThreadPool();
        Task task = new Task();
        // 执行任务并获取 Future 对象
        Future<String> future = executor.submit(task);
        // 关闭线程池
        executor.shutdown();
         
        System.out.println("当前为主线程");
         
        try {
            // 获取子线程返回值
            System.out.println(future.get());
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }
         
        System.out.println("所有任务执行完毕");
    }
}

class Task implements Callable<String>{
    @Override
    public String call() throws Exception {
        return "子线程返回值";
    }
}
----

[NOTE]
通过 `Callable` 创建新线程，一般是和 `ExecutorService` 配合来使用的


==== 基于线程池的方式

[source,java]
----
// 创建线程池
ExecutorService threadPool = Executors.newFixedThreadPool(10);
while(true) {
    // 提交多个线程任务,并执行
    threadPool.execute(new Runnable() { 
        @Override
        public void run() {
            System.out.println(Thread.currentThread().getName() + " is running ..");
            try {
                Thread.sleep(3000);
            } catch (InterruptedException e) {
            }
        }
    });
}
----

[TIP]
 `为什么推荐采用线程池的方式` ： + 
线程和数据库连接的  `创建`  和  `销毁`  都是非常浪费资源的，使用线程池避免了频繁的创建和销毁。


==== Runable和Callable区别

----
1. Runable 没有返回值，Callable有返回值（返回Future对象）
2. Runable不能抛出异常，Callable可以抛出异常
3. Callable在JUC包下，属于线程安全的接口
----

[NOTE]
Callalble接口支持返回执行结果，需要调用FutureTask.get()得到，此方法会阻塞主进程的继续往下执行，如果不调用不会阻塞。这个其实和 CountDownLatch + Runable 实现主线程等待所有子线程执行完再继续执行的功能类似。




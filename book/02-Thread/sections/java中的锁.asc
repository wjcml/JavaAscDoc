=== Java中的锁


==== 乐观锁

&emsp;&emsp;总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，只在更新的时候会判断一下在此期间别人有没有去更新这个数据。Java中的乐观锁基本是通过CAS实现的。

[TIP]
乐观锁不能解决 ABA 问题。解决 ABA 问题，可以在修改数据中添加一个版本号，修改数据前，根据版本号确定数据是否被修改过。

==== 悲观锁

&emsp;&emsp;总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞，直到它拿到锁。

==== 自旋锁

&emsp;&emsp;自旋锁原理非常简单，如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需自旋，等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗。线程自旋需消耗 cup 的，如果一直获取不到锁，则线程长时间占用CPU自旋，需要设定一个自旋等待最大事件在最大等待时间内仍未获得锁就会停止自旋进入阻塞状态。

==== 公平锁和非公平锁

&emsp;&emsp;所谓公平指的是线程获取到锁时，争抢锁资源的线程是否遵循先到先得的规则。

&emsp;&emsp;公平锁指的是锁的分配机制是公平的，通常先对锁提出获取请求的线程会先被分配到锁。非公平锁中存在后来的线程先获得锁资源的情况。

==== 可重入锁

&emsp;&emsp;如果当前线程已经获得了某个监视器对象所持有的锁，那么该线程在该方法中调用另外一个同步方法也同样持有该锁。可重入锁最大的作用就是避免死锁。

==== 读写锁

&emsp;&emsp;读锁： 允许多个线程获取读锁，同时访问同一个资源。

&emsp;&emsp;写锁： 只允许一个线程获取写锁，不允许同时访问同一个资源。

&emsp;&emsp;Java中的读写锁：ReentrantReadWriteLock

==== 独占锁和共享锁

&emsp;&emsp;独占锁：每次只能有一个线程能持有锁

&emsp;&emsp;共享锁：允许多个线程同时获取锁，并发访问共享资源

==== 锁粗化

&emsp;&emsp;锁粗化是一种优化技术： 如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作都是出现在循环体体之中，就算真的没有线程竞争，频繁地进行互斥同步操作将会导致不必要的性能损耗，所以就采取了一种方案：把加锁的范围扩展（粗化）到整个操作序列的外部，这样加锁解锁的频率就会大大降低，从而减少了性能损耗。


=== 常见问题

.TCP粘包、拆包解决办法？

发送端给每个数据包添加包首部，首部中应该至少包含数据包的长度。 + 
发送端将每个数据包封装为固定长度（不够的可以通过补0填充）。 + 
可以在数据包之间设置边界，如添加特殊符号，这样，接收端通过这个边界就可以将不同的数据包拆分开。 

.什么是netty？为什么要用netty？netty的应用场景？

netty是基于NIO的网络通信框架，能够快速简单的开发网络应用程序 + 
极大的优化了TCP，UDP套接字服务器编程，性能更好，更加安全；支持多种协议（http，ftp，rtp等）；自带解码器（如可以解决TCP粘包，拆包） + 
作为rpc框架通信工具，实现http服务器，即时通讯，消息推送等

.netty的组件有哪些？分别有什么作用？

Channel：Channel是 Netty 抽象出来对网络 I/O 进行操作的接口，如 bind()、connect()、read()、write() 等 + 
EventLoop（事件循环）：EventLoop 的主要作用实际就是负责监听网络事件并调用事件处理器进行相关 I/O 操作的处理。 + 
ChannelHandler：ChannelHandler 是消息的具体处理器， + 
ChannelPipeline：ChannelPipeline 为 ChannelHandler 的链，因为一条消息可以被多个ChannelHandler处理，我们可以在 ChannelPipeline 上通过 addLast() 方法添加一个或者多个ChannelHandler，让消息按照顺序被处理。

.EventloopGroup 了解么?和 EventLoop 啥关系?

EventLoopGroup 包含多个 EventLoop + 
我们实现服务端的时候，一般会初始化两个线程组： + 
bossGroup :接收连接。 + 
workerGroup ：负责具体的处理，交由对应的 Handler 处理。

.netty的线程模型？
单线程模型：所有的 I/O 操作都由一个线程完成，既要监听客户端连接，又要又要发送/读取请求或应答/响应消息 + 
多线程模型：一个 Acceptor 线程只负责监听客户端的连接，一个 NIO 线程池负责网络的 I/O 操作 + 
主从多线程模型：从一个 主线程 NIO 线程池中选择一个线程作为 Acceptor 线程，绑定监听端口，接收客户端连接的连接，其他线程负责后续的接入认证等工作。连接建立完成后，Sub NIO 线程池负责具体处理 I/O 读写。 


.零拷贝

Netty的零拷贝体现在三个方面：

. Netty 接收和发送 ByteBuffer 采用的都是堆外直接内存，使用堆外直接内存进行 Socket 的读/写，不需要进行字节缓冲区的二次拷贝。如果使用传统的堆内存进行 Socket 的读/写，则 JVM 会将堆内存Buffer数据拷贝到堆外直接内存中，然后才写入Socket中。与堆外直接内存相比，使用传统的堆内存，在消息发送过程中多了一次缓冲区的内存拷贝
. 在网络传输中，一条消息可能会被分割成多个多个数据包进行发送，只有当收到一个完整的数据包后，才能完成解码工作。Netty 通过组合内存的方式把这些数据包组合到一块，而不是对每个数据块进行一次拷贝。
. 传统拷贝文件的方法需要先把文件采用 FileInputStream 文件输入流读取到一个临时的 byte[] 数组中，然后通过 FileOutputStream 文件输出流，把临时的 byte[] 数据内容写入到目的文件中。当拷贝大文件时，频繁的内存拷贝操作会消耗大量的系统资源。Netty 底层运用 Java NIO d的 FileChannel.transfer() 方法，该方法依赖操作系统实现零拷贝，可以直接将文件缓冲区的数据发送到目标的 Channel 中，避免了传统的通过循环方式导致的内存数据拷贝问题。




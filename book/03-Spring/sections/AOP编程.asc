=== Spring AOP

*AOP* 全称为Aspect-Oriented Programming, 中文翻译为面向切面编程，AOP可以将业务系统中一些公共的点提取出来，进行封装，让我们在编写业务代码的时候，只关注业务的一个 *切点*，在切点的前后做相应的处理，简化了系统需求与实现之间的对比关系，使得整个系统的实现更具有模块化。

AOP通常用在 *安全检查*，*系统日志*，*事物管理*，*性能统计*，*异常处理* 等地方。

*Spring AOP* 采用的是 *动态代理机制* 和 *字节码生成技术* 实现的。这两种方式都是 *在运行期间*，*为被代理的目标类生成一个代理对象*，而 *将横切逻辑添加到这个代理对象中*，系统最终使用的是添加了横切逻辑的代理对象，不是被代理的目标对象。

image::AOP系统关系示意图.png[]

==== Java的三种代理方式
java静态代理，JDK动态代理和cglib动态代理

*参考文档一*： 《Sring揭秘》--王福强 （推荐，这本书写的真的很好）

*三种代理的实现代码Demo*： https://github.com/wjcml/java_engineer_road_code/tree/master/java_proxy[java的三种代理模式, window="_blank"]

==== 静态代理
由程序员创建或由特定工具自动生成源代码，再对其编译。在程序运行前，代理类的 `.class` 文件就已经存在了。

静态代理方式需要代理对象和目标对象实现同一个接口。  + 
*缺点*：冗余，不宜维护




==== JDK动态代理
*JDK动态代理* 可以在运行期间，为相应的 *接口（interface）* 动态生成相应的代理对象。所以，我们可以将横切关注点的逻辑封装到动态代理的 *InvocationHandler* 中，然后在系统运行期间，根据横切关注点需要植入的模块位置，将横切逻辑植入到相应的 *代理类* 中。

JDK动态代理的方式需要 *被代理的目标对象实现相应的接口*，因为这种动态代理机制只针对接口有效。

JDK动态代理必须实现 *InvocationHandler* 接口，通过 *反射* 代理方法，比较消耗系统性能，但可以减少代理类的数量，使用更灵活。




==== cglib动态代理
我们知道，Java虚拟机加载class文件都是符合一定的规范的，所以，只要交给Java虚拟机运行的文件符合Java Class规范，程序的运行就没有问题。在Java中，我们可以使用 *ASM* 或者 *cglib* 工具库，在程序运行期间，动态的构建字节码的class文件。

在这样的前提下，我们可以为需要添加横切逻辑的模块类，在运行期间，通过动态字节码增强技术，为这些需要被代理的类 *生成相应的子类*，而 *将横切逻辑加入到这些子类中*，让程序在运行期间 *使用的是这些动态生成的子类*，从而达到将横切逻辑添加到系统中的目的。

[NOTE]
====
cglib包的底层是通过使用一个小而快的字节码处理框架ASM(什么是ASM？)，来转换字节码并生成新的类。

cglib代理无需实现接口，通过生成类字节码实现代理，比反射稍快，不存在性能问题，但cglib的代理对象会继承目标对象，需要重写方法，所以目标对象不能为 *final类*。
====

[NOTE]
====
cglib与JDK动态代理最大的区别就是JDK动态代理的对象必须实现一个或多个接口，使用cglib代理的对象则无需实现接口。

*JDK动态代理*：代理的是接口   + 
*cglib代理*：代理的是类

在Spring AOP中，判断使用 *JDK动态代理*，还是使用 *cglib代理*，就是根据被代理的目标类是否实现 *接口* 来判断的。
====


==== Spring AOP代理失效问题？

Spring AOP代理，同一个对象中的内部方法调用导致代理失效。

===== 原因分析
出现这种问题的原因是因为Spring AOP的实现机制造成的。Spring AOP采用的是 *JDK动态代理* 和 *cglib动态代理* 实现的AOP，*在运行的时候，会动态生成对应的代理对象*，而且 *具体的横切逻辑也会被添加到代理对象中*，只要调用的是 *代理对象* 上的方法，通常就可以保证目标对象上的方法执行可以被拦截。

但是，在对象内部方法调用时会失效，我们要知道，在代理方法中，不管添加多少的横切逻辑，最终都会调用 *目标对象* 上的同一方法来执行最初定义的方法逻辑。

*示例分析*

下面这个例子来自于《Sring揭秘--王福强》。
[source, java]
----
public class NestableInvacationBO {
    public void method1(){
        method2();
        System.out.println("method1 executed!");
    }

    public void method2(){
        System.out.println("method2 executed!");
    }
}
----

上方代码中的类（NestableInvocationBO）中定义了两个方法，并且method1()方法会调用method2()方法。

现在，我们要使用Spring AOP拦截该类定义的方法method1()和method2()，下面是一个 *AspectJ*，定义了简单的切面逻辑。

[source, java]
----
@Aspect
public class PerformanceTraceAspect {
    @Pointcut("execution(public void *.method1())")
    public void method1(){}
    @Pointcut("execution(public void *.method2())")
    public void method2(){}
    @Pointcut("method1() || method2()")
    public void compositePointcut(){}

    @Around("compositePointcut()")
    public Object performanceTrace(ProceedingJoinPoint joinPoint) throws Throwable{
        StopWatch watch = new StopWatch();
        try {
            watch.start();
            return joinPoint.proceed();
        }finally {
            watch.stop();
            System.out.println(String.format("PT in method[%s] >>>>> %s", joinPoint.getSignature().getName(), watch.toString()));
        }
    }

}
----

其中定义的 *Around Advice* 会拦截 *compositePointcut()* 指定的 Joinpoint，即method1()或者method2()的执行。

如果将 *PerformanceTranceAspect* 中定义的横切逻辑织入到 *NestableInvocationBO* 中，然后运行代码并查看结果：

[source, java]
----
        AspectJProxyFactory weaver = new AspectJProxyFactory(new NestableInvacationBO());
        weaver.setProxyTargetClass(true);
        weaver.addAspect(PerformanceTraceAspect.class);
        Object proxy = weaver.getProxy();
        ((NestableInvacationBO) proxy).method2();
        ((NestableInvacationBO) proxy).method1();
----

*输出结果*：

image::spring_aop代码1.png[]

从输出结果我们可以看出，我们直接从外部调用 *method2()* 的时候，该方法被正常拦截。但是当我们从外部调用 *method1()* 的时候，却只有 *method1()* 被成功拦截，而 *method1()* 中的 *method2()* 没有被拦截，因为输出日志中只有 *PT in method[method1]* 的信息

下面是 *代理对象* 和 *目标对象* 的方法调用关系(*Spring AOP对象内部方法嵌套调用示意图*)：

image::spring_aop对象内部方法嵌套调用示意图.png[]

从上图我们可以看出，在 *代理对象的method1()* 经过层层拦截器之后，最终会将调用转向 *目标对象的method1()*，之后的调用流程全部都是走在 *目标对象（TargetObject）* 之上，当method1()调用method2()的时候，它调用的是 *TargetObject上的method2()*，而不是 *ProxyObject上的method2()*。要知道，针对method2()的横切逻辑，只是织入到了 *代理对象（ProxyObject）* 上的method2()方法中，所以，在method1()中所调用的method2()没有被拦截成功。


[NOTE]
====
 正因为上述原因，可以解释在Spring中，为什么 @Transactional，@Cacheable 等注解会失效了。
====






=== 容器背后的秘密
在没有特别说明的情况下，以下描述以 *BeanFactory* 进行的分析，*ApplicationContext* 有一些不一样。

==== 容器功能实现阶段
Spring的IOC容器会以某种方式加载Configuration Metadata（通常也就是XML格式的配置信息），然后根据这些信息绑定整个系统的对象，最终组装成一个可用的基于轻量级容器的应用系统。

Spring的IOC容器实现以上功能的过程，基本上可以按照类似的流程划分为两个阶段，即 *容器启动阶段* 和 *Bean实例化阶段*。如下图所示：

image::spring_ioc容器功能实现的各个阶段.png[]

.*1. 容器启动阶段*

容器启动伊始，首先会通过某种途径加载 *Configuration MetaData*。除了代码方式比较直接，在大部分情况下，容器需要依赖某些工具类（*BeanDefinitionReader*）对加载的Configuration MetaData进行解析和分析，*并将分析后的信息映射为相应的BeanDefinition*，最后把这些保存了bean定义必要信息的BeanDefinition，*注册到相应的BeanDefinitionRegistry*，这样容器启动工作就完成了。

.*2. Bean实例化阶段*

经过第一阶段，现在 *所有的bean定义信息都通过BeanDefinition的方式注册到了BeanDefinitionRegistry中*。当某个请求方通过容器的 *getBean* 方法明确地请求某个对象，或者因依赖关系容器需要隐式地调用getBean方法时，就会触发第二阶段的活动。

该阶段，容器会 *首先检查所请求的对象之前是否已经初始化*。*如果没有，则会根据注册的BeanDefinition所提供的信息实例化被请求对象，并为其注入依赖*。如果该对象实现了某些回调接口，也会根据回调接口的要求来装配它。当该对象装配完毕之后，容器会立即将其返回请求方使用。如果说第一阶段只是根据图纸装配生产线的话，那么第二阶段就是使用装配好的生产线来生产具体的产品了。


==== 插手“容器的启动”
Spring提供了一种叫做 *BeanFactoryPostProcessor* 的容器扩展机制。*该机制允许我们在容器实例化相应对象之前，对注册到容器的BeanDefinition所保存的信息做相应的修改*。这就相当于在容器实现的 *第一阶段最后加入一道工序*，*让我们对最终的BeanDefinition做一些额外的操作，比如修改其中bean定义的某些属性，为bean定义增加其他信息* 等。

如果要自定义实现 *BeanFactoryPostProcessor*，通常我们需要实现 *BeanFactoryPostProcessor接口*。同时，因为一个 *容器可能拥有多个BeanFactoryPostProcessor*，这个时候可能需要实现类同时实现 *Spring的Ordered接口*，以 *保证各个BeanFactoryPostProcessor可以按照预先设定的顺序执行*（如果顺序紧要的话）。但是，因为Spring已经提供了几个现成的BeanFactoryPostProcessor实现类，所以，大多时候，我们很少自己去实现某个BeanFactoryPostProcessor。其中，*PropertyPlaceholderConfigurer* 和 *PropertyOverrideConfigurer* 是两个比较常用的BeanFactoryPostProcessor。另外，为了处理配置文件中的数据类型与真正的业务对象所定义的数据类型转换，Spring还允许我们通过 *CustomEditorConfigurer* 来注册自定义的PropertyEditor以补助容器中默认的PropertyEditor。

[NOTE]
====
上述讲到的interface对应的完整包路径如下：

BeanFactoryPostProcessor：org.springframework.beans.factory.config.BeanFactoryPostProcessor

Ordered：org.springframework.core.Ordered

PropertyPlaceholderConfigurer：org.springframework.beans.factory.config.PropertyPlaceholderConfigurer

PropertyOverrideConfigurer：org.springframework.beans.factory.config.PropertyOverrideConfigurer

CustomEditorConfigurer：org.springframework.beans.factory.config.CustomEditorConfigurer
====


.*举个例子*

通常情况下，我们 *不想将类似于系统管理相关的信息同业务对象相关的配置信息混杂到XML配置文件中*，以免部署或者维护期间因为改动繁杂的XML配置文件而出现问题。我们会将一些数据库连接信息、邮件服务器等相关信息单独配置到一个 *properties* 文件中，这样，如果因系统资源变动的话，只需要关注这些简单properties配置文件即可。

PropertyPlaceholderConfigurer允许我们在XML配置文件中使用 *占位符*（PlaceHolder），并将这些占位符所代表的资源单独配置到简单的properties文件中来加载。以数据源的配置为例：

[source, xml]
----
<bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close">
<property name="url">
    <value>${jdbc.url}</value>
</property>
<property name="driverClassName">
    <value>${jdbc.driver}</value>
</property>
<property name="username">
    <value>${jdbc.username}</value>
</property>
<property name="password">
    <value>${jdbc.password}</value>
</property>
</bean>
----

jdbc.properties配置文件
[source, properties]
----
jdbc.url=jdbc:mysql://server/MAIN?useUnicode=true&characterEncoding=ms932&failOverReadOnly=false&roundRobinLoadBalance=true
jdbc.driver=com.mysql.jdbc.Driver
jdbc.username=your username
jdbc.password=your password
----


==== 了解Bean的一生



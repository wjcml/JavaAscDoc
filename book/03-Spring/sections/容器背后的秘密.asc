[[容器背后的秘密]]

=== 容器背后的秘密
在没有特别说明的情况下，以下描述以 *BeanFactory* 进行的分析，*ApplicationContext* 有一些不一样。

==== 容器功能实现阶段
Spring的IOC容器会以某种方式加载Configuration Metadata（通常也就是XML格式的配置信息），然后根据这些信息绑定整个系统的对象，最终组装成一个可用的基于轻量级容器的应用系统。

Spring的IOC容器实现以上功能的过程，基本上可以按照类似的流程划分为两个阶段，即 *容器启动阶段* 和 *Bean实例化阶段*。如下图所示：

image::spring_ioc容器功能实现的各个阶段.png[]

.*1. 容器启动阶段*

容器启动伊始，首先会通过某种途径加载 *Configuration MetaData*。除了代码方式比较直接，在大部分情况下，容器需要依赖某些工具类（*BeanDefinitionReader*）对加载的Configuration MetaData进行解析和分析，*并将分析后的信息映射为相应的BeanDefinition*，最后把这些保存了bean定义必要信息的BeanDefinition，*注册到相应的BeanDefinitionRegistry*，这样容器启动工作就完成了。

.*2. Bean实例化阶段*

经过第一阶段，现在 *所有的bean定义信息都通过BeanDefinition的方式注册到了BeanDefinitionRegistry中*。当某个请求方通过容器的 *getBean* 方法明确地请求某个对象，或者因依赖关系容器需要隐式地调用getBean方法时，就会触发第二阶段的活动。

该阶段，容器会 *首先检查所请求的对象之前是否已经初始化*。*如果没有，则会根据注册的BeanDefinition所提供的信息实例化被请求对象，并为其注入依赖*。如果该对象实现了某些回调接口，也会根据回调接口的要求来装配它。当该对象装配完毕之后，容器会立即将其返回请求方使用。如果说第一阶段只是根据图纸装配生产线的话，那么第二阶段就是使用装配好的生产线来生产具体的产品了。


==== 插手“容器的启动”
Spring提供了一种叫做 *BeanFactoryPostProcessor* 的容器扩展机制。*该机制允许我们在容器实例化相应对象之前，对注册到容器的BeanDefinition所保存的信息做相应的修改*。这就相当于在容器实现的 *第一阶段最后加入一道工序*，*让我们对最终的BeanDefinition做一些额外的操作，比如修改其中bean定义的某些属性，为bean定义增加其他信息* 等。

如果要自定义实现 *BeanFactoryPostProcessor*，通常我们需要实现 *BeanFactoryPostProcessor接口*。同时，因为一个 *容器可能拥有多个BeanFactoryPostProcessor*，这个时候可能需要实现类同时实现 *Spring的Ordered接口*，以 *保证各个BeanFactoryPostProcessor可以按照预先设定的顺序执行*（如果顺序紧要的话）。但是，因为Spring已经提供了几个现成的BeanFactoryPostProcessor实现类，所以，大多时候，我们很少自己去实现某个BeanFactoryPostProcessor。其中，*PropertyPlaceholderConfigurer* 和 *PropertyOverrideConfigurer* 是两个比较常用的BeanFactoryPostProcessor。另外，为了处理配置文件中的数据类型与真正的业务对象所定义的数据类型转换，Spring还允许我们通过 *CustomEditorConfigurer* 来注册自定义的PropertyEditor以补助容器中默认的PropertyEditor。

[NOTE]
====
上述讲到的interface对应的完整包路径如下：

BeanFactoryPostProcessor：org.springframework.beans.factory.config.BeanFactoryPostProcessor

Ordered：org.springframework.core.Ordered

PropertyPlaceholderConfigurer：org.springframework.beans.factory.config.PropertyPlaceholderConfigurer

PropertyOverrideConfigurer：org.springframework.beans.factory.config.PropertyOverrideConfigurer

CustomEditorConfigurer：org.springframework.beans.factory.config.CustomEditorConfigurer
====


.*举个例子*

通常情况下，我们 *不想将类似于系统管理相关的信息同业务对象相关的配置信息混杂到XML配置文件中*，以免部署或者维护期间因为改动繁杂的XML配置文件而出现问题。我们会将一些数据库连接信息、邮件服务器等相关信息单独配置到一个 *properties* 文件中，这样，如果因系统资源变动的话，只需要关注这些简单properties配置文件即可。

PropertyPlaceholderConfigurer允许我们在XML配置文件中使用 *占位符*（PlaceHolder），并将这些占位符所代表的资源单独配置到简单的properties文件中来加载。以数据源的配置为例：

[source, xml]
----
<bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close">
<property name="url">
    <value>${jdbc.url}</value>
</property>
<property name="driverClassName">
    <value>${jdbc.driver}</value>
</property>
<property name="username">
    <value>${jdbc.username}</value>
</property>
<property name="password">
    <value>${jdbc.password}</value>
</property>
</bean>
----

jdbc.properties配置文件
[source, properties]
----
jdbc.url=jdbc:mysql://server/MAIN?useUnicode=true&characterEncoding=ms932&failOverReadOnly=false&roundRobinLoadBalance=true
jdbc.driver=com.mysql.jdbc.Driver
jdbc.username=your username
jdbc.password=your password
----


==== 了解Bean的一生
*容器启动之后，并不会马上就实例化相应的bean定义*。我们知道，容器现在仅仅拥有所有对象的BeanDefinition来保存实例化阶段将要用的必要信息。只有当请求方通过BeanFactory的getBean()方法来请求某个对象实例的时候，才有可能触发Bean实例化阶段的活动。BeanFactory的getBean方法可以被客户端对象 *显式调用*，也可以在容器内部隐式地被调用。*隐式调用有如下两种情况*。

. 对于 *BeanFactory* 来说，对象实例化默认采用延迟初始化。通常情况下，当对象A被请求而需要第一次实例化的时候，如果它所依赖的对象B之前同样没有被实例化，那么容器会先实例化对象A所依赖的对象。这时容器内部就会首先实例化对象B，以及对象 A依赖的其他还没有被实例化的对象。这种情况是容器内部调用getBean()，对于本次请求的请求方是隐式的。

. *ApplicationContext启动之后会实例化所有的bean定义*，这个特性在本文档中已经多次提到。但ApplicationContext在实现的过程中依然遵循Spring容器实现流程的两个阶段，只不过它会 *在启动阶段的活动完成之后，紧接着调用注册到该容器的所有bean定义的实例化方法getBean()*。这就是为什么当你得到ApplicationContext类型的容器引用时，容器内所有对象已经被全部实例化完成 。

之所以说getBean()方法是有可能触发Bean实例化阶段的活动，是因为 *只有当对应某个bean定义的getBean()方法第一次被调用时，不管是显式的还是隐式的，Bean实例化阶段的活动才会被触发，第二次被调用则会直接返回容器缓存的第一次实例化完的对象实例（prototype类型bean除外）。当getBean()方法内部发现该bean定义之前还没有被实例化之后，会通过createBean()方法来进行具体的对象实例化*。下面是Bean实例化的过程图：

image::Bean的实例化过程.png[]

===== Bean实例化的过程解析

.*1. Bean的实例化与BeanWrapper*

容器在内部实现的时候，采用“策略模式（Strategy Pattern）”来决定采用何种方式初始化bean实例。通常，可以通过反射或者CGLIB动态字节码生成来初始化相应的bean实例或者动态生成其子类。

容器只要根据相应bean定义的 *BeanDefintion* 取得实例化信息，然后实例化并返回实例化完成的对象实例。但是，返回方式上有些“点缀”。不是直接返回构造完成的对象实例，而是以BeanWrapper对构造完成的对象实例进行包裹，返回相应的BeanWrapper实例。

至此，第一步结束。

第二步就是设置属性值（成员变量的值），第一步返回的 *BeanWrapper实例* 就是这一步来设置属性值的。


[[各色的Aware接口]]
.*2. 各色的Aware接口*

当对象实例化完成并且相关属性以及依赖设置完成之后，Spring容器会检查当前对象实例是否实现了一系列的以Aware命名结尾的接口定义。如果是，则 *将这些Aware接口定义中规定的依赖注入给当前对象实例*。

比如说： 

. *org.springframework.beans.factory.BeanNameAware* 接口，如果Spring容器检测到当前对象实例实现了该接口，会将该对象实例的bean定义对应的beanName设置到当前对象实例。

. *org.springframework.beans.factory.BeanFactoryAware* 接口，如果对 象声明实现了BeanFactoryAware接口，BeanFactory容器会将自身设置到当前对象实例。这样，当前对象实例就拥有了一个BeanFactory容器的引用，并且可以对这个容器内允许访问的对象按照需要进行访问。

.*3. BeanPostProcessor*

*BeanPostProcessor* 的概念容易与 *BeanFactoryPostProcessor* 的概念混淆。但只要记住 *BeanPostProcessor* 是存在于对象实例化阶段，而 *BeanFactoryPostProcessor* 则是存在于容器启动阶段，这两个概念就比较容易区分了。

BeanPostProcessor会处理容器内 *所有符合条件的实例化后的对象实例*。该接口声明了两个方法，分别在两个不同的时机执行，见如下代码定义：

[source, java]
----
public interface BeanPostProcessor{
Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException;

Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException;
}
----

BeanPostProcessor的两个方法中都传入了原来的对象实例的引用，这为我们扩展容器的对象实例化过程中的行为提供了极大的便利，我们几乎可以对传入的对象实例执行任何的操作。


[NOTE]
====
 怎么判断实例化后的对象是否符合 BeanPostProcessor 的处理条件？

*就是在这两个方法里面做判断，符合条件就执行*。下面是一个自定义的 *BeanPostProcessor*，在执行 *postProcessBeforeInitialization* 方法的时候，判断这个Bean是否是 PasswordDecodable ，如果是，就执行里面的操作。这只是一个例子，不一定是判断是否属于某个类，就看用户想做什么样的事情，看如下代码就比较容易理解了。

[source, java]
----
public class PasswordDecodePostProcessor implements BeanPostProcessor {
    public Object postProcessAfterInitialization(Object object, String beanName) throws BeansException {
        return object;
    }
    public Object postProcessBeforeInitialization(Object object, String beanName) throws BeansException {
        // 判断这个Bean是否满足某个条件，如果满足就会执行相应的操作
        if(object instanceof PasswordDecodable){
            String encodedPassword = ((PasswordDecodable)object).getEncodedPassword();
            String decodedPassword = decodePassword(encodedPassword);
            ((PasswordDecodable)object).setDecodedPassword(decodedPassword);
        }
        return object;
    }

    private String decodePassword(String encodedPassword) {
        // 实现解码逻辑
        return encodedPassword;
    }
}
----
====


.*4. InitializingBean和init-method*

org.springframework.beans.factory.InitializingBean是容器内部广泛使用的一个对象生命周期标识接口，其定义如下：

[source, java]
----
public interface InitializingBean {
    void afterPropertiesSet() throws Exception;
}
----

该接口定义很简单，其作用在于，在对象实例化过程调用过“BeanPostProcessor的前置处理”之后，会接着检测当前对象是否实现了InitializingBean接口，如果是，则会调用其afterPropertiesSet()方法进一步调整对象实例的状态。比如，在有些情况下，某个业务对象实例化完成后，还不能处于可以使用状态。这个时候就可以让该业务对象实现该接口，并在方法afterPropertiesSet()中完成对该业务对象的后续处理。

虽然该接口在Spring容器内部广泛使用，但如果真的让我们的业务对象实现这个接口，则显得Spring容器比较具有侵入性。所以，Spring还提供了另一种方式来指定自定义的对象初始化操作，那就是在XML配置的时候，使用<bean>的init-method属性。

通过init-method，系统中业务对象的自定义初始化操作可以以任何方式命名，而不再受制于InitializingBean的afterPropertiesSet()。如果配置了自定义的init-method方法，那么就会在“BeanPostProcessor的后置处理”之前执行指定的init-method方法。


.*5. DisposableBean与destroy-method*

当所有的一切，该设置的设置，该注入的注入，该调用的调用完成之后，容器将检查singleton类型的bean实例，看其是否实现了org.springframework.beans.factory.DisposableBean接口。或者其对应的bean定义是否通过<bean>的destroy-method属性指定了自定义的对象销毁方法。如果是，就会为该实例注册一个用于对象销毁的回调（Callback），以便在这些singleton类型的对象实例销毁之前，执行销毁逻辑。

不过，这些自定义的对象销毁逻辑，在对象实例初始化完成并注册了相关的回调方法之后，并不会马上执行。回调方法注册后，返回的对象实例即处于使用状态，只有该对象实例不再被使用的时候，才会执行相关的自定义销毁逻辑，此时通常也就是Spring容器关闭的时候。但Spring容器在关闭之前，不会聪明到自动调用这些回调方法。所以，需要我们告知容器，在哪个时间点来执行对象的自定义销毁方法。

[NOTE]
====
 总结Spring Bean的生命周期

- 根据 *BeanDefintion* 中的信息，创建一个Bean的实例。
- 如果存在一些属性值，设置属性值。
- 检查是否实现了一些 *Aware* 接口，如果是，则将这些Aware接口定义中规定的依赖注入给当前对象实例。
- 执行 *BeanPostProcessor* 中的 *postProcessBeforeInitialization()* 方法，BeanPostProcessor会处理容器内 *所有符合条件的实例化后的对象实例*。
- 检查是否实现了 *InitializingBean* 接口，执行 *afterPropertiesSet()* 方法。
- 如果 Bean 在配置文件中的定义包含 *init-method* 属性，执行指定的方法。
- 执行 *BeanPostProcessor* 中的 *postProcessAfterInitialization()* 方法，BeanPostProcessor会处理容器内 *所有符合条件的实例化后的对象实例*。
- 然后就是这个Bean处于使用中了。
- 当要销毁 Bean 的时候，如果 Bean 实现了 *DisposableBean* 接口，执行 *destroy()* 方法。或者，如果 Bean 在配置文件中的定义包含 *destroy-method* 属性，执行指定的方法。
====






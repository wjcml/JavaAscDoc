=== Spring事务
事务是逻辑上的一组操作，要么都执行，要么都不执行。

==== 事务的四大特性（ACID）

image::事务四大特性.png[]

*原子性*：事务所包含的全部操作是一个整体，要么全部提交成功，要么全部失败。 + 
*一致性*：要求事务所包含的操作不能违反数据资源的一致性检查，即在事务执行之后数据之间保持着一致。 + 
*隔离性*：多个事务执行，各个事务之间相互影响的程度。当两个事务同时访问一个数据资源的时候，不同的隔离级别决定了各个事务对该数据资源访问的不同行为。事务隔离分为不同级别，包括 *读未提交（Read uncommitted）、读已提交（read committed）、可重复读（repeatable read）和串行化（Serializable）*。 + 
*持久性*：一旦整个事务的操作成功提交，对数据所作的变更将被记载并且不可逆转。

==== 并发事务带来的问题？
*脏读*：当一个事务正在访问数据并且对数据进行了修改，但事务还没有提交，另一个事务可以“看到”这个没有提交的更新结果。这样的会造成的问题就是，如果第一个事务回滚，那么第二个事务之前所“看到”的数据就是一笔脏数据。 

*不可重复读*：指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。 

*幻读*：幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。

[NOTE]
====
*不可重复读和幻读区别*：
不可重复读的重点是修改比如多次读取一条记录发现其中某些列的值被修改，幻读的重点在于新增或者删除比如多次读取一条记录发现记录增多或减少了
====


==== 事务的隔离级别有哪些？
*READ-UNCOMMITTED(读取未提交)*： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。 + 
*READ-COMMITTED(读取已提交)*： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。 + 
*REPEATABLE-READ(可重复读)*： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。 + 
*SERIALIZABLE(可串行化)*： 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。

image::事务隔离级别.png[]

[NOTE]
====
MYSQL默认的事务隔离级别是 *REPEATABLE-READ(可重复读)*。
====

==== 事务的传播行为
*事务传播行为是为了解决业务层方法之间互相调用的事务问题*

如果有两个方法，都被 *@Tansactional* 注释（即这是两个事务方法），*方法A（aMethod）调用了方法B（bMethod）*，在业务中会有以下问题的出现：
如果 *bMethod* 出现异常，是让 *bMethod* 提交还是两个一起回滚？

在Spring中，提供了7种事务的传播机制，下面是Spring定义的源码：

[source, java]
----
package org.springframework.transaction.annotation;

public enum Propagation {
    REQUIRED(0),
    SUPPORTS(1),
    MANDATORY(2),
    REQUIRES_NEW(3),
    NOT_SUPPORTED(4),
    NEVER(5),
    NESTED(6);

    private final int value;

    private Propagation(int value) {
        this.value = value;
    }

    public int value() {
        return this.value;
    }
}
----

*1. Propagation.REQUIRED*

*如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。* Spring中 *@Transactional* 默认的事务传播行为，也是我们经常使用的传播行为。

. 如果外部方法没有开启事务的话，*Propagation.REQUIRED* 修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。
. 如果外部方法开启事务并且被 *Propagation.REQUIRED* 的话，所有 *Propagation.REQUIRED* 修饰的内部方法和外部方法均属于同一事务 ，只要一个方法回滚，整个事务均回滚。

举例说明：如果我们上面的 *aMethod()* 和 *bMethod()* 使用的都是 *Propagation.REQUIRED* 传播行为的话，两者使用的就是同一个事务，只要其中一个方法回滚，整个事务均回滚。

[source, java]
----
Class A {
    @Transactional(propagation=Propagation.REQUIRED)
    public void aMethod {
        //do something
        B b = new B();
        b.bMethod();
    }
}

Class B {
    @Transactional(propagation=Propagation.REQUIRED)
    public void bMethod {
       //do something
    }
}
----

*2. Propagation.REQUIRES_NEW*

*创建一个新的事务，如果当前存在事务，则把当前事务挂起*。也就是说不管外部方法是否开启事务，*Propagation.REQUIRES_NEW* 修饰的内部方法会新开启自己的事务，且开启的事务 *相互独立，互不干扰*。

举例说明：如果我们上面的 *bMethod()* 使用 *Propagation.REQUIRES_NEW* 事务传播行为修饰，*aMethod()* 还是用 *Propagation.REQUIRED* 修饰的话。如果 *aMethod()* 发生异常回滚， *bMethod()* 不会跟着回滚，因为 *bMethod()* 开启了独立的事务。但是，如果 *bMethod()* 抛出了 *未被捕获* 的异常并且这个异常满足事务回滚规则的话，*aMethod()* 同样也会回滚，因为这个异常被 *aMethod()* 的事务管理机制检测到了。

[source, java]
----
Class A {
    @Transactional(propagation=Propagation.REQUIRED)
    public void aMethod {
        //do something
        B b = new B();
        b.bMethod();
    }
}

Class B {
    @Transactional(propagation=Propagation.REQUIRES_NEW)
    public void bMethod {
       //do something
    }
}
----

*3. Propagation.NESTED*

*如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于Propagation.REQUIRED。*

. 在外部方法未开启事务的情况下 *Propagation.NESTED* 和 *Propagation.REQUIRED* 作用相同，修饰的内部方法都会新开启自己的事务，且开启的事务相互独立，互不干扰。
. 如果外部方法开启事务的话，*Propagation.NESTED* 修饰的内部方法属于外部事务的子事务，外部主事务回滚的话，子事务也会回滚，而内部子事务可以单独回滚而不影响外部主事务和其他子事务。

举例说明：如果 *aMethod()* 回滚的话，*bMethod()* 和 *bMethod2()* 都要回滚，而 *bMethod()* 回滚的话，并不会造成 *aMethod()* 和 *bMethod()2* 回滚。

[source, java]
----
Class A {
    @Transactional(propagation=Propagation.REQUIRED)
    public void aMethod {
        //do something
        B b = new B();
        b.bMethod();
        b.bMethod2();
    }
}

Class B {
    @Transactional(propagation=Propagation.NESTED)
    public void bMethod {
       //do something
    }
    @Transactional(propagation=Propagation.NESTED)
    public void bMethod2 {
       //do something
    }
}
----

*4. Propagation.MANDATORY*

*如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。*

*5. Propagation.SUPPORTS*

*如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。*


*6. Propagation.NOT_SUPPORTED*

*以非事务方式运行，如果当前存在事务，则把当前事务挂起。*


*7. Propagation.NEVER*

*以非事务方式运行，如果当前存在事务，则抛出异常。*

> > *Propagation.SUPPORTS*，*Propagation.NOT_SUPPORTED*，*Propagation.NEVER* 这三种事务的传播行为，用得比较少，配置以后可能会导致事务不会回滚。


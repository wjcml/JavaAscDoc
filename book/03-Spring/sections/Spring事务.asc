=== Spring事务
*事务是逻辑上的一组操作，要么都执行，要么都不执行。*

==== Spring对事务的支持
程序时候支持事务首先取决于数据库，比如MySQL，*innodb* 引擎支持事务，*myisam* 引擎不支持事务。

==== 事务的四大特性（ACID）

image::事务四大特性.png[]

*原子性*：事务所包含的全部操作是一个整体，要么全部提交成功，要么全部失败。 + 
*一致性*：要求事务所包含的操作不能违反数据资源的一致性检查，即在事务执行之后数据之间保持着一致。 + 
*隔离性*：多个事务执行，各个事务之间相互影响的程度。当两个事务同时访问一个数据资源的时候，不同的隔离级别决定了各个事务对该数据资源访问的不同行为。事务隔离分为不同级别，包括 *读未提交（Read uncommitted）、读已提交（read committed）、可重复读（repeatable read）和串行化（Serializable）*。 + 
*持久性*：一旦整个事务的操作成功提交，对数据所作的变更将被记载并且不可逆转。

[NOTE]
====
*MySQL 怎么保证原子性的？*

我们知道如果想要保证事务的原子性，就需要在异常发生时，对已经执行的操作进行 *回滚*，在 *MySQL* 中，恢复机制是通过 *回滚日志（undo log）* 实现的，所有事务进行的修改都会先先记录到这个回滚日志中，然后再执行相关的操作。如果执行过程中遇到异常的话，我们直接利用 *回滚日志* 中的信息将数据回滚到修改之前的样子即可！并且，回滚日志会先于数据持久化到磁盘上。这样就保证了即使遇到数据库突然宕机等情况，当用户再次启动数据库的时候，数据库还能够通过查询回滚日志来回滚将之前未完成的事务。
====

==== 并发事务带来的问题？
*脏读*：当一个事务正在访问数据并且对数据进行了修改，但事务还没有提交，另一个事务可以“看到”这个没有提交的更新结果。这样的会造成的问题就是，如果第一个事务回滚，那么第二个事务之前所“看到”的数据就是一笔脏数据。 

*不可重复读*：指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。 

*幻读*：幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。

[NOTE]
====
*不可重复读和幻读区别*：
不可重复读的重点是修改比如多次读取一条记录发现其中某些列的值被修改，幻读的重点在于新增或者删除比如多次读取一条记录发现记录增多或减少了
====


==== 事务的隔离级别有哪些？
*READ-UNCOMMITTED(读取未提交)*： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。 + 
*READ-COMMITTED(读取已提交)*： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。 + 
*REPEATABLE-READ(可重复读)*： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。 + 
*SERIALIZABLE(可串行化)*： 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。

image::事务隔离级别.png[]

[NOTE]
====
MYSQL默认的事务隔离级别是 *REPEATABLE-READ(可重复读)*。
====

==== 事务的传播行为
*事务传播行为是为了解决业务层方法之间互相调用的事务问题*

如果有两个方法，都被 *@Tansactional* 注释（即这是两个事务方法），*方法A（aMethod）调用了方法B（bMethod）*，在业务中会有以下问题的出现：
如果 *bMethod* 出现异常，是让 *bMethod* 提交还是两个一起回滚？

在Spring中，提供了7种事务的传播机制，下面是Spring定义的源码：

[source, java]
----
package org.springframework.transaction.annotation;

public enum Propagation {
    REQUIRED(0),
    SUPPORTS(1),
    MANDATORY(2),
    REQUIRES_NEW(3),
    NOT_SUPPORTED(4),
    NEVER(5),
    NESTED(6);

    private final int value;

    private Propagation(int value) {
        this.value = value;
    }

    public int value() {
        return this.value;
    }
}
----

===== 1. Propagation.REQUIRED

*如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。* Spring中 *@Transactional* 默认的事务传播行为，也是我们经常使用的传播行为。

. 如果外部方法没有开启事务的话，*Propagation.REQUIRED* 修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。
. 如果外部方法开启事务并且被 *Propagation.REQUIRED* 的话，所有 *Propagation.REQUIRED* 修饰的内部方法和外部方法均属于同一事务 ，只要一个方法回滚，整个事务均回滚。

举例说明：如果我们上面的 *aMethod()* 和 *bMethod()* 使用的都是 *Propagation.REQUIRED* 传播行为的话，两者使用的就是同一个事务，只要其中一个方法回滚，整个事务均回滚。

[source, java]
----
Class A {
    @Transactional(propagation=Propagation.REQUIRED)
    public void aMethod {
        //do something
        B b = new B();
        b.bMethod();
    }
}

Class B {
    @Transactional(propagation=Propagation.REQUIRED)
    public void bMethod {
       //do something
    }
}
----

===== 2. Propagation.REQUIRES_NEW

*创建一个新的事务，如果当前存在事务，则把当前事务挂起*。也就是说不管外部方法是否开启事务，*Propagation.REQUIRES_NEW* 修饰的内部方法会新开启自己的事务，且开启的事务 *相互独立，互不干扰*。

举例说明：如果我们上面的 *bMethod()* 使用 *Propagation.REQUIRES_NEW* 事务传播行为修饰，*aMethod()* 还是用 *Propagation.REQUIRED* 修饰的话。如果 *aMethod()* 发生异常回滚， *bMethod()* 不会跟着回滚，因为 *bMethod()* 开启了独立的事务。但是，如果 *bMethod()* 抛出了 *未被捕获* 的异常并且这个异常满足事务回滚规则的话，*aMethod()* 同样也会回滚，因为这个异常被 *aMethod()* 的事务管理机制检测到了。

[source, java]
----
Class A {
    @Transactional(propagation=Propagation.REQUIRED)
    public void aMethod {
        //do something
        B b = new B();
        b.bMethod();
    }
}

Class B {
    @Transactional(propagation=Propagation.REQUIRES_NEW)
    public void bMethod {
       //do something
    }
}
----

===== 3. Propagation.NESTED

*如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于Propagation.REQUIRED。*

. 在外部方法未开启事务的情况下 *Propagation.NESTED* 和 *Propagation.REQUIRED* 作用相同，修饰的内部方法都会新开启自己的事务，且开启的事务相互独立，互不干扰。
. 如果外部方法开启事务的话，*Propagation.NESTED* 修饰的内部方法属于外部事务的子事务，外部主事务回滚的话，子事务也会回滚，而内部子事务可以单独回滚而不影响外部主事务和其他子事务。

举例说明：如果 *aMethod()* 回滚的话，*bMethod()* 和 *bMethod2()* 都要回滚，而 *bMethod()* 回滚的话，并不会造成 *aMethod()* 和 *bMethod()2* 回滚。

[source, java]
----
Class A {
    @Transactional(propagation=Propagation.REQUIRED)
    public void aMethod {
        //do something
        B b = new B();
        b.bMethod();
        b.bMethod2();
    }
}

Class B {
    @Transactional(propagation=Propagation.NESTED)
    public void bMethod {
       //do something
    }
    @Transactional(propagation=Propagation.NESTED)
    public void bMethod2 {
       //do something
    }
}
----

===== 4. Propagation.MANDATORY

*如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。*

===== 5. Propagation.SUPPORTS

*如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。*


===== 6. Propagation.NOT_SUPPORTED

*以非事务方式运行，如果当前存在事务，则把当前事务挂起。*


===== 7. Propagation.NEVER

*以非事务方式运行，如果当前存在事务，则抛出异常。*

> > *Propagation.SUPPORTS*，*Propagation.NOT_SUPPORTED*，*Propagation.NEVER* 这三种事务的传播行为，用得比较少，配置以后可能会导致事务不会回滚。


==== Spring配置事务的两种方式

===== 编程式事务
通过 *TransactionTemplate* 或者 *TransactionManager*  在代码中手动管理事务的方式，但是我们在实际开发中是很少用到的，可以了解一下，帮助自己理解Spring事务。

.使用 *TransactionTemplate* 进行编程式事务管理
[source, java]
----
@Autowired
private TransactionTemplate transactionTemplate;
public void testTransaction() {

    transactionTemplate.execute(new TransactionCallbackWithoutResult() {
        @Override
        protected void doInTransactionWithoutResult(TransactionStatus transactionStatus) {

            try {
                // ....  业务代码
            } catch (Exception e){
                //回滚
                transactionStatus.setRollbackOnly();
            }

        }
    });
}
----

.使用 *TransactionManager* 进行编程式事务管理
[source, java]
----
@Autowired
private PlatformTransactionManager transactionManager;

public void testTransaction() {

  TransactionStatus status = transactionManager.getTransaction(new DefaultTransactionDefinition());
          try {
               // ....  业务代码
              transactionManager.commit(status);
          } catch (Exception e) {
              transactionManager.rollback(status);
          }
}
----

===== 声明式事务
声明式事务是基于 *Spring AOP* 实现的，一般使用 *@Transactional* 注解进行事务管理，这样的事务管理方式 *代码侵入性小*，推荐使用声明式事务。


==== Spring事务管理接口

Spring的事务框架将开发过程中的事务管理相关的关注点进行适当的分离，并对这些关注点进行合理的抽象。通过Spring的事务框架，我们可以按照 *统一的编程模型* 来进行事务编程，却不用关心所使用的数据访问技术（JDBC、iBatis、Hibernate等）和具体要访问的什么类型的事务资源。

Spring的事务框架设计理念的基本原则是：*让事务管理的关注点与数据访问关注点相分离*。
. 当在业务层使用事务的抽象API进行事务界定的时候，不需要关心事务将要加诸于上事务资源是什么，对不同的事务资源的管理将由相应的框架实现类来操心。 + 
. 当在数据访问层对可能参与事务的数据资源进行访问的时候，只需要使用相应的数据访问API进行数据访问，不需要关心当前的事务资源如何参与事务或者是否需要参与事务。这同样将由事务框架类来打理。

对于开发人员来说，唯一需要关心的，就是 *通过抽象后的事务管理API对当前事务进行界定* 而已。


===== 事务管理三大核心接口
*PlatformTransactionManager*：（平台）事务管理器，负责界定事务的边界。 + 
*TransactionDefinition*：负责定义事务相关属性，（包括事务隔离级别、传播行为、超时、只读、回滚规则）。*PlatformTransactionManager* 将根据 *TransactionDefinition* 定义的属性来开启相关事务。 + 
*TransactionStatus*：负责事务开启到事务结束期间的事务状态。

它们之间的依赖关系如下图：

image::spring事务接口依赖图.png[]


===== PlatformTransactionManager：事务界定
负责界定事务的边界，这个接口中定义了三个方法：

[source, java]
----
package org.springframework.transaction;

import org.springframework.lang.Nullable;

public interface PlatformTransactionManager {
    //获得事务
    TransactionStatus getTransaction(@Nullable TransactionDefinition var1) throws TransactionException;
    //提交事务
    void commit(TransactionStatus var1) throws TransactionException;
    //回滚事务
    void rollback(TransactionStatus var1) throws TransactionException;
}
----

Spring采用 *策略模式*，通过实现这个接口，不同的数据访问方式，采用不同的事务管理器去处理，比如，Spring 为各个平台如 JDBC/iBatis(DataSourceTransactionManager)、Hibernate(HibernateTransactionManager)、JPA(JpaTransactionManager)等都提供了对应的事务管理器，但是具体的实现就是各个平台自己的事情了。


===== TransactionDefinition：事务属性
负责定义事务相关属性，事务管理器接口 *PlatformTransactionManager* 通过 *getTransaction(TransactionDefinition definition)* 方法来得到一个事务，这个方法里面的参数是 *TransactionDefinition* 类。Spring源码如下：

[source, java]
----
package org.springframework.transaction;

import org.springframework.lang.Nullable;

public interface TransactionDefinition {
    int PROPAGATION_REQUIRED = 0;
    int PROPAGATION_SUPPORTS = 1;
    int PROPAGATION_MANDATORY = 2;
    int PROPAGATION_REQUIRES_NEW = 3;
    int PROPAGATION_NOT_SUPPORTED = 4;
    int PROPAGATION_NEVER = 5;
    int PROPAGATION_NESTED = 6;
    int ISOLATION_DEFAULT = -1;
    int ISOLATION_READ_UNCOMMITTED = 1;
    int ISOLATION_READ_COMMITTED = 2;
    int ISOLATION_REPEATABLE_READ = 4;
    int ISOLATION_SERIALIZABLE = 8;
    int TIMEOUT_DEFAULT = -1;
    // 返回事务的传播行为，默认值为 REQUIRED。
    int getPropagationBehavior();
    //返回事务的隔离级别，默认值是 DEFAULT
    int getIsolationLevel();
    // 返回事务的超时时间，默认值为-1。如果超过该时间限制但事务还没有完成，则自动回滚事务。
    int getTimeout();
    // 返回是否为只读事务，默认值为 false
    boolean isReadOnly();

    @Nullable
    String getName();
}
----


===== TransactionStatus：事务状态
负责事务开启到事务结束期间的事务状态。

*TransactionStatus* 接口用来记录事务的状态 该接口定义了一组方法,用来获取或判断事务的相应状态信息。*PlatformTransactionManager.getTransaction(…)* 方法返回一个 *TransactionStatus* 对象。

Spring源码如下：
[source, java]
----
public interface TransactionStatus{
    boolean isNewTransaction(); // 是否是新的事务
    boolean hasSavepoint(); // 是否有恢复点
    void setRollbackOnly();  // 设置为只回滚
    boolean isRollbackOnly(); // 是否为只回滚
    boolean isCompleted; // 是否已完成
}
----



=== Java集合

参考文章：  +
https://juejin.im/post/6844903966103306247[详解Java集合框架，让你全面掌握！, window="_blank"] +
https://www.runoob.com/java/java-collections.html[菜鸟教程-Java 集合框架, window="_blank"]

集合框架归纳如下图： 

image::java集合02.png[]


Java集合类主要由两个根接口Collection和Map派生出来的，Collection派生出了三个子接口：List、Set、Queue（Java5新增的队列），因此Java集合大致也可分成List、Set、Queue、Map四种接口体系，（注意：Map不是Collection的子接口）。

集合框架如下图：

image::java集合01.png[]


- 其中List代表了有序可重复集合，可直接根据元素的索引来访问；
- Set代表无序不可重复集合，只能根据元素本身来访问；
- Queue是队列集合；
- Map代表的是存储key-value对的集合，可根据元素的key来访问value。 

上图中淡绿色背景覆盖的是集合体系中常用的实现类，分别是ArrayList、LinkedList、ArrayQueue、HashSet、TreeSet、HashMap、TreeMap等实现类。

==== Collection 子接口之 List

===== Arraylist 和 Vector 的区别？

*ArrayList* 是 *List* 的主要实现类，底层使用 *Object[]* 存储，适用于频繁的查找工作，*线程不安全*；

*Vector* 是 *List* 的古老实现类，底层使用 *Object[]* 存储，*线程安全的*。

===== Arraylist 与 LinkedList 区别？

.1. 是否保证线程安全
ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；

.2. 底层数据结构
*Arraylist* 底层使用的是 *Object 数组*；*LinkedList* 底层使用的是 *双向链表* 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。）

.3. 插入和删除是否受元素位置的影响
- ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行add(E e)方法的时候， ArrayList 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（add(int index, E element)）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。
- LinkedList 采用链表存储，所以，如果是在头尾插入或者删除元素不受元素位置的影响（add(E e)、addFirst(E e)、addLast(E e)、removeFirst() 、 removeLast()），近似 O(1)，如果是要在指定位置 i 插入和删除元素的话（add(int index, E element)，remove(Object o)） 时间复杂度近似为 O(n) ，因为需要先移动到指定位置再插入。

.4. 是否支持快速随机访问
LinkedList 不支持高效的随机元素访问，而 ArrayList 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于get(int index)方法)。

.5. 内存空间占用
ArrayList 的空 间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。


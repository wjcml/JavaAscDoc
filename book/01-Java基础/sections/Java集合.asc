=== Java集合

参考文章：  +
https://juejin.im/post/6844903966103306247[详解Java集合框架，让你全面掌握！, window="_blank"] +
https://www.runoob.com/java/java-collections.html[菜鸟教程-Java 集合框架, window="_blank"]

集合框架归纳如下图： 

image::java集合02.png[]


Java集合类主要由两个根接口Collection和Map派生出来的，Collection派生出了三个子接口：List、Set、Queue（Java5新增的队列），因此Java集合大致也可分成List、Set、Queue、Map四种接口体系，（注意：Map不是Collection的子接口）。

集合框架如下图：

image::java集合01.png[]


- 其中List代表了有序可重复集合，可直接根据元素的索引来访问；
- Set代表无序不可重复集合，只能根据元素本身来访问；
- Queue是队列集合；
- Map代表的是存储key-value对的集合，可根据元素的key来访问value。 

上图中淡绿色背景覆盖的是集合体系中常用的实现类，分别是ArrayList、LinkedList、ArrayQueue、HashSet、TreeSet、HashMap、TreeMap等实现类。

==== Collection 子接口之 List

===== Arraylist 和 Vector 的区别？

*ArrayList* 是 *List* 的主要实现类，底层使用 *Object[]* 存储，适用于频繁的查找工作，*线程不安全*；

*Vector* 是 *List* 的古老实现类，底层使用 *Object[]* 存储，*线程安全的*。

===== Arraylist 与 LinkedList 区别？

.1. 是否保证线程安全
ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；

.2. 底层数据结构
*Arraylist* 底层使用的是 *Object 数组*；*LinkedList* 底层使用的是 *双向链表* 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。）

.3. 插入和删除是否受元素位置的影响
- ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行add(E e)方法的时候， ArrayList 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（add(int index, E element)）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。
- LinkedList 采用链表存储，所以，如果是在头尾插入或者删除元素不受元素位置的影响（add(E e)、addFirst(E e)、addLast(E e)、removeFirst() 、 removeLast()），近似 O(1)，如果是要在指定位置 i 插入和删除元素的话（add(int index, E element)，remove(Object o)） 时间复杂度近似为 O(n) ，因为需要先移动到指定位置再插入。

.4. 是否支持快速随机访问
LinkedList 不支持高效的随机元素访问，而 ArrayList 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于get(int index)方法)。

.5. 内存空间占用
ArrayList 的空 间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。


==== Collection 子接口之 Set

===== 比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同

*HashSet* 是 Set 接口的主要实现类 ，HashSet 的底层是 *HashMap*，*线程不安全的*，可以存储 null 值；

*LinkedHashSet* 是 HashSet 的子类，能够按照添加的顺序遍历；

*TreeSet* 底层使用红黑树，能够按照添加元素的顺序进行遍历，排序的方式有自然排序和定制排序。


==== Map 接口

===== HashMap 和 Hashtable 的区别

.1. 线程是否安全
HashMap 是 *非线程安全的*，HashTable 是 *线程安全* 的,因为 HashTable 内部的方法基本都经过 *synchronized* 修饰。（如果你要保证线程安全的话就使用 ConcurrentHashMap 吧！）；

.2. 效率
因为线程安全的问题，HashMap 要比 HashTable 效率高一点。另外，HashTable 基本被淘汰，不要在代码中使用它；

.3. 对 Null key 和 Null value 的支持
- HashMap 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个；
- HashTable 不允许有 null 键和 null 值，否则会抛出 NullPointerException。

.4. 初始容量大小和每次扩充容量大小的不同 
- ① 创建时如果不指定容量初始值，Hashtable 默认的初始大小为 *11*，之后每次扩充，容量变为原来的 *2n+1*。HashMap 默认的初始化大小为 *16*。之后每次扩充，容量变为原来的 *2* 倍。
- ② 创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为 *2* 的幂次方大小（HashMap 中的tableSizeFor()方法保证）。也就是说 HashMap *总是使用 2 的幂* 作为哈希表的大小,后面会介绍到为什么是 2 的幂次方。

.5. 底层数据结构
*JDK1.8* 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 *8*）（将链表转换成红黑树前会判断，如果当前数组的长度小于 *64*，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。


===== HashMap 和 HashSet 区别

*HashSet 底层就是基于 HashMap 实现的*。（HashSet 的源码非常非常少，因为除了 clone()、writeObject()、readObject()是 HashSet 自己不得不实现之外，其他方法都是直接调用 HashMap 中的方法。

.HashSet 如何检查重复?

当你把对象加入HashSet时，HashSet 会先计算对象的 *hashcode* 值来判断对象加入的位置，同时也会与其他加入的对象的 hashcode 值作比较，如果没有相符的 hashcode，HashSet 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用equals()方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让加入操作成功。


===== HashMap 和 TreeMap 区别

*相比于 HashMap 来说 TreeMap 主要多了对集合中的元素根据键排序的能力以及对集合内元素的搜索的能力。*




=== java关键字

[cols="1,1,1,1,1,1,1,1"] 
.Java 中常见的关键字
|===
|访问控制|public|protected|default|private|||
|类，方法和变量修饰符|abstract|class|extends|final|implements|interface|native
||new|static|strictfp|synchronized|transient|volatile|
|程序控制|break|continue|return|do|while|if|else
||for|instanceof|switch|case|default||
|错误处理|try|catch|throw|throws|finally||
|包相关|import|package|||||
|基本类型|boolean|byte|char|double|float|int|long
||short|null|true|false|||
|变量引用|super|this|void||||
|保留字|goto|const|||||
|===



==== static关键字

static 可以修饰 类，成员变量，成员方法，静态代码块

- 修饰类（静态内部类）
- 修饰成员变量（静态变量）：静态变量属于类，只要静态变量所在的类被加载，这个静态变量就会被分配空间，在 *内存中只有一份*，所有对象共享这个静态变量。
- 修饰成员方法（静态成员方法）：静态成员方法属于类，不需要创建对象就可以使用。而非静态方法属于对象，只有在对象创建出来以后才可以被使用。静态方法里面只能访问所属类的静态成员变量和静态成员方法。
- 静态代码块：静态代码块经常被用来初始化静态变量，在类加载的初始化阶段会执行为静态变量赋值的语句和静态代码块的内容，*静态代码块只会被执行一次*。


==== Java程序初始化的顺序（Java实例化的过程）

- 父类的静态变量、父类的静态代码块 （谁在前，谁先初始化）
- 子类的静态变量、子类的静态代码块（谁在前，谁先初始化）
- 父类的非静态变量、父类的非静态代码块（谁在前，谁先初始化）、父类的构造函数
- 子类的非静态变量、子类的非静态代码块（谁在前，谁先初始化）、子类的构造函数
- 静态成员变量或静态代码块>main方法>非静态成员变量或非静态代码块>构造方法
- 如果在子类构造函数中，显示调用了父类的构造方法（即使用了super()），则先调用子类的构造函数，再调用父类的。


==== StringBuffer和StringBuilder

====
`*String*` 被 `final` 修饰，长度大小不可变 +
`*StringBuffer*` 和 `*StringBuilder*` 长度可变 +
`*StringBuffer*` 线程安全， `*StringBuilder*` 线程不安全 +
`*StringBuilder*` 速度快
====


==== volatile

参考文档： https://www.cnblogs.com/javazhiyin/p/13521567.html["面试官最爱的 volatile 关键字，这些问题你都搞懂了没？",window="_blank"]

===== volatile基本介绍

volatile可以看成是synchronized的一种轻量级的实现，但volatile并不能完全代替synchronized，volatile有synchronized可见性的特性，但没有synchronized原子性的特性。

可见性即用volatile关键字修饰的成员变量表明该变量不存在工作线程的副本，线程每次直接都从主内存中读取，每次读取的都是最新的值，这也就保证了变量对其他线程的 *可见性*。

另外，使用volatile还能确保变量不能被 *重排序*，保证了 *有序性*。

被 volatile 修饰的变量具有的特性：

- *保证此变量对所有线程的可见性*
- *禁止指令重排序优化*

===== volatile怎么保证变量对所有线程的可见性

首先我们补充一个重要的概念 *内存可见性*：

在JVM内存模型：*主内存* 和 线程独立的 *工作内存*。Java内存模型规定，对于多个线程共享的变量，存储在主内存当中，每个线程都有自己独立的工作内存（比如CPU的寄存器），线程只能访问自己的工作内存，不可以访问其它线程的工作内存。工作内存中保存了主内存共享变量的副本，线程要操作这些共享变量，只能通过操作工作内存中的副本来实现，操作完毕之后再同步回到主内存当中。

volatile保证可见性的原理是在每次都从主内存直接读取，因此每次访问都是主内存中最新的版本。所以volatile关键字的作用之一就是保证变量修改的实时可见性。

所以：

- *每次直接从主内存读取值*。
- *每次写入强制修改主内存的值*。


===== volatile是如何防止指令重排序优化的呢？

volatile关键字通过 “*内存屏障*” 的方式来防止指令被重排序，即：在每个 volatile 读写操作前后加一种CPU指令。


[NOTE]
内存屏障: 内存屏障（Memory Barrier，或有时叫做内存栅栏，Memory Fence）是一种CPU指令，用于控制特定条件下的重排序和内存可见性问题。


==== synchronized

===== 实现原理

JVM 是通过进入、退出对象监视器( Monitor )来实现对方法、同步块的同步的。

具体实现是在编译之后在 *同步方法调用前* 加入一个 *monitor.enter* 指令，在 *退出方法和异常处* 插入 *monitor.exit* 的指令。

其本质就是对一个对象监视器( Monitor )进行获取，而这个获取过程具有排他性从而达到了同一时刻只能一个线程访问的目的。

而对于没有获取到锁的线程将会阻塞到方法入口处，直到获取锁的线程 monitor.exit 之后才能尝试继续获取锁。

流程图如下:

image::synchronized实现同步原理的流程图.jpg[]



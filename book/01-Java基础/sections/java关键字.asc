=== java关键字

[cols="1,1,1,1,1,1,1,1"] 
.Java 中常见的关键字
|===
|访问控制|public|protected|default|private|||
|类，方法和变量修饰符|abstract|class|extends|final|implements|interface|native
||new|static|strictfp|synchronized|transient|volatile|
|程序控制|break|continue|return|do|while|if|else
||for|instanceof|switch|case|default||
|错误处理|try|catch|throw|throws|finally||
|包相关|import|package|||||
|基本类型|boolean|byte|char|double|float|int|long
||short|null|true|false|||
|变量引用|super|this|void||||
|保留字|goto|const|||||
|===



==== static关键字

static 可以修饰 类，成员变量，成员方法，静态代码块

- 修饰类（静态内部类）
- 修饰成员变量（静态变量）：静态变量属于类，只要静态变量所在的类被加载，这个静态变量就会被分配空间，在 *内存中只有一份*，所有对象共享这个静态变量。
- 修饰成员方法（静态成员方法）：静态成员方法属于类，不需要创建对象就可以使用。而非静态方法属于对象，只有在对象创建出来以后才可以被使用。静态方法里面只能访问所属类的静态成员变量和静态成员方法。
- 静态代码块：静态代码块经常被用来初始化静态变量，在类加载的初始化阶段会执行为静态变量赋值的语句和静态代码块的内容，*静态代码块只会被执行一次*。


==== Java程序初始化的顺序（Java实例化的过程）

- 父类的静态变量、父类的静态代码块 （谁在前，谁先初始化）
- 子类的静态变量、子类的静态代码块（谁在前，谁先初始化）
- 父类的非静态变量、父类的非静态代码块（谁在前，谁先初始化）、父类的构造函数
- 子类的非静态变量、子类的非静态代码块（谁在前，谁先初始化）、子类的构造函数
- 静态成员变量或静态代码块>main方法>非静态成员变量或非静态代码块>构造方法
- 如果在子类构造函数中，显示调用了父类的构造方法（即使用了super()），则先调用子类的构造函数，再调用父类的。


==== StringBuffer和StringBuilder

====
`*String*` 被 `final` 修饰，长度大小不可变 +
`*StringBuffer*` 和 `*StringBuilder*` 长度可变 +
`*StringBuffer*` 线程安全， `*StringBuilder*` 线程不安全 +
`*StringBuilder*` 速度快
====


==== volatile

参考文档： https://www.cnblogs.com/javazhiyin/p/13521567.html["面试官最爱的 volatile 关键字，这些问题你都搞懂了没？",window="_blank"]

===== volatile 的作用


被 volatile 修饰的变量具有的特性：

- *保证此变量对所有线程的可见性*
- *禁止指令重排序优化*

===== 可见性问题

&emsp;&emsp;内存可见性是指当一个线程修改了某个变量的值，其它线程总是能知道这个变量变化。也就是说，如果线程 A 修改了共享变量 V 的值，那么线程 B 在使用 V 的值时，能立即读到 V 的最新值。

&emsp;&emsp;使用 volatile 修饰共享变量后，每个线程要操作变量时会从主内存中将变量拷贝到本地内存作为副本。当线程操作变量副本并写回主内存后，会通过 *CPU 总线嗅探机制* 告知其他线程该变量副本已经失效，需要重新从主内存中读取。(CPU 总线嗅探机制 是实现缓存一致性的常见机制，想要了解更多可以看看这篇文章 https://zhuanlan.zhihu.com/p/138819184["volatile 关键字，你真的理解吗？", window="_blank"])

所以：

- *每次直接从主内存读取值*。
- *每次写入强制修改主内存的值*。

需要注意的是：volatile 是不能保证原子性的。

[NOTE]
====
&emsp;&emsp;在 Java 内存模型（JMM）中规定：线程之间的共享变量存储在主内存中，每个线程都有一个私有的本地内存，本地内存中存储了该线程以读/写共享变量的副本。这里所说的共享变量指的是实例变量和类变量，不包含局部变量，因为局部变量是线程私有的，因此不存在竞争问题。

- 每一个线程还存在自己的工作内存，线程的工作内存，保留了被线程使用的变量的工作副本。
- 线程对变量的所有的操作（读，取）都必须在工作内存中完成，而不能直接读写主内存中的变量。
- 不同线程之间也不能直接访问对方工作内存中的变量，线程间变量的值的传递需要通过主内存中转来完成。

image::JMM示意图.webp[]
====


===== 指令重排序

&emsp;&emsp;指令重排序是JVM为了优化指令，提高程序运行效率，在不影响 单线程程序 执行结果的前提下，尽可能地提高并行度的一种优化措施（JVM虚拟机的一种优化措施）。


[source, java]
----
volatile boolean isOK = false;

//假设以下代码在线程A执行
A.init();
isOK=true;

//假设以下代码在线程B执行
while(!isOK){
  sleep();
}
B.init();
----

&emsp;&emsp;线程在初始化的时候，B线程处于睡眠状态，等待A线程完成初始化的时候才能够进行自己的初始化。这里的先后关系依赖于isOK这个变量。

&emsp;&emsp;如果没有volatile修饰isOK这个变量，那么isOK的赋值就可能出现在A.init()之前（指令重排序,Java虚拟机的一种优化措施），此时A没有初始化，而B的初始化就破坏了它们之前形成的那种依赖关系，可能就会出错。

&emsp;&emsp;volatile关键字通过 “*内存屏障*” 的方式来防止指令被重排序，即：*在每个 volatile 读写操作前后加一种CPU指令*。


[NOTE]
内存屏障: 内存屏障（Memory Barrier，或有时叫做内存栅栏，Memory Fence）是一种CPU指令，用于控制特定条件下的重排序和内存可见性问题。


==== synchronized

https://blog.csdn.net/Hdu_lc14015312/article/details/100053032["java中的几种锁（很详细）-小白收藏", window="_blank"]

https://juejin.cn/post/6973571891915128846[这一次，彻底搞懂Java中的synchronized关键字, window="_blank"]

===== 实现原理

JVM 是通过进入、退出对象监视器( Monitor )来实现对方法、同步块的同步的。

具体实现是在编译之后在 *同步方法调用前* 加入一个 *monitor.enter* 指令，在 *退出方法和异常处* 插入 *monitor.exit* 的指令。

其本质就是对一个对象监视器( Monitor )进行获取，而这个获取过程具有排他性从而达到了同一时刻只能一个线程访问的目的。

而对于没有获取到锁的线程将会阻塞到方法入口处，直到获取锁的线程 monitor.exit 之后才能尝试继续获取锁。

流程图如下:

image::synchronized实现同步原理的流程图.jpg[]



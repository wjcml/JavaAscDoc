=== 序列化和反序列化

==== 什么是序列化和反序列化

如果我们需要持久化 Java 对象比如将 Java 对象保存在文件中，或者在网络传输 Java 对象，这些场景都需要用到序列化。

简单来说：

- 序列化： 将数据结构或对象转换成二进制字节流的过程
- 反序列化：将在序列化过程中所生成的二进制字节流的过程转换成数据结构或者对象的过程

image::序列化和反序列化.png[]


.1. 为什么需要序列化和反序列化？
首先，我们要知道，*序列化是为了方便持久化或者数据传输*。那么为什么需要序列化呢？

第一种情况是：一般情况下Java对象的声明周期都比Java虚拟机的要短，实际应用中我们希望在JVM停止运行之后能够持久化指定的对象，这时候就需要把对象进行序列化之后保存。

第二种情况是：需要把Java对象通过网络进行传输的时候。因为数据只能够以二进制的形式在网络中进行传输，因此当把对象通过网络发送出去之前需要先序列化成二进制数据，在接收端读到二进制数据之后反序列化成Java对象。


.2. 为什么Java序列化一定要实现Serializable接口？
在Java中实现了Serializable接口后, JVM会在底层帮我们实现序列化和反序列化, 如果我们不实现Serializable接口, 那自己去写一套序列化和反序列化代码也行。

.3. 实现Serializable接口就算了, 为什么还要显示指定serialVersionUID的值？
因为序列化对象时，如果不显示的设置serialVersionUID，Java在序列化时会根据对象属性自动的生成一个serialVersionUID，再进行存储或用作网络传输。在反序列化时，会根据对象属性自动再生成一个新的serialVersionUID，和序列化时生成的serialVersionUID进行比对，两个serialVersionUID相同则反序列化成功，否则就会抛异常。

而当显示的设置serialVersionUID后，Java在序列化和反序列化对象时，生成的serialVersionUID都为我们设定的serialVersionUID，这样就保证了反序列化的成功。


.4. String为什么不用实现Serializable接口呢？
查看 String 的源码可以知道，String 已经默认实现了 Serializable 接口


==== transient

Java 序列化中如果有些字段不想进行序列化，怎么办？

对于不想进行序列化的变量，使用 transient 关键字修饰。

transient 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 transient 修饰的变量值不会被持久化和恢复。

关于 transient 还有几点注意：

- transient 只能修饰变量，不能修饰类和方法。
- transient 修饰的变量，在反序列化后变量值将会被置成类型的默认值。例如，如果是修饰 int 类型，那么反序列后结果就是 0。
- static 变量因为不属于任何对象(Object)，所以无论有没有 transient 关键字修饰，均不会被序列化。


